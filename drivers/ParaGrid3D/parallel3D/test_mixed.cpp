#include <stdio.h>
#include <math.h>
#include "definitions.h"

//============================================================================

int Type_Boundary(double x, double y, double z){
  //return DIRICHLET;
  if (x<0.0001) return NEUMANN;
  else
    return DIRICHLET;
}

//============================================================================
// This problem determines the pressure (from where the velocity) for mesh in
// bioscreen.out, Mesh_functions in Problem1. The mesh has layer, marked with
// atribut 1.
//============================================================================
void func_K(real *c, real K[][3], int atribut){
  real eps = 1.;
  
  K[0][0] = eps;  K[0][1] = 0.;  K[0][2] = 0.;
  K[1][0] = 0. ;  K[1][1] = eps; K[1][2] = 0.;
  K[2][0] = 0. ;  K[2][1] = 0.;  K[2][2] = eps;
}

//============================================================================
void func_K_Inv(real *c, real K[][3], int atribut){
  real eps = 1.;
  
  K[0][0] = eps;  K[0][1] = 0.;  K[0][2] = 0.;
  K[1][0] = 0. ;  K[1][1] = eps; K[1][2] = 0.;
  K[2][0] = 0. ;  K[2][1] = 0.;  K[2][2] = eps;
}

//============================================================================

double func_c(real *c){
  return 0.;
}

//============================================================================

double func_f(real *c){
  //  return 0;
  return 2*( c[0]*c[1]*(1.-c[0])*(1.-c[1]) +
	     c[1]*c[2]*(1.-c[1])*(1.-c[2]) +
	     c[0]*c[2]*(1.-c[0])*(1.-c[2]) );
}

//============================================================================
// Dirichlet boundary value
//============================================================================
double func_u0(real *c){
  return 0.;
}

//============================================================================
// Neumann BC - this gives contribution to the stiffness matrix 
// ( K grad( u)).n + gn . u  = g
//============================================================================
double func_gn(real *c){
  return -(1.-2*c[0])*c[1]*c[2]*(1.-c[1])*(1.-c[2]);
}

//============================================================================
// Neumann BC - this gives contribution in the RHS b
//============================================================================
double func_g(real *c){
  return  -(1.-2*c[0])*c[1]*c[2]*(1.-c[1])*(1.-c[2]);
}

//============================================================================
// The following funcitons are not used
//============================================================================
double   exact(real *c){
  //return 0.+5.;
  return c[0]*c[1]*c[2]*(1-c[0])*(1-c[1])*(1-c[2]);
}

//============================================================================

void exact_K_grad_p(real *c, real result[3]){
  result[0] = (1.-2*c[0])*c[1]*c[2]*(1.-c[1])*(1.-c[2]);
  result[1] = (1.-2*c[1])*c[0]*c[2]*(1.-c[0])*(1.-c[2]);
  result[2] = (1.-2*c[2])*c[0]*c[1]*(1.-c[0])*(1.-c[1]);
}

//============================================================================

void func_b(real *c, real b[3]){
  b[0] = b[1] = b[2] = 0.;
}

//============================================================================

