-----------------------------------------------------------------

Documentation for AMG

I.    General description
II.   Compiling the code
III.  Using AMG
IV.   Fortran interface

APPENDIX A.  Matrix and Vector formats.

-----------------------------------------------------------------

I. General Description

This version of AMG is a C/Fortran code based on the original
all-Fortran code, AMGS01 (AMG for systems).  Much of the documentation
below is from the User's Manual for that code.  The main differences
are the interface, and the use of dynamic memory allocation.

AMGS01 is a version of AMG meant to be applied to "systems"
problems, that is, linear systems in which approximations to
a number of different functions (e.g., pressure, components of
velocity or displacement, etc.) are being approximated.
The code was designed to be fairly general. An arbitrary
number of different functions can be approximated (although
this is somewhat artificially limited to 5 (or 10) in the
current code). Each such function is called an UNKNOWN. Each
unknown is defined at some set of POINTS (generally a real
point in the physical domain). The sets of points for each
unknown can be the same (as in a vertex-centered discretization,
for example), or disjoint (as in a staggered grid), or
a combination. That is, a set of points, 1, 2, ..., NP is
defined, and at each point (possibly different for each point)
some subset of the unknowns (which we denote by 1, 2, ..., NU)
is defined. Each such point/unknown pair is associated with
a VARIABLE (one of the quantities to be approximated). The
variables are numbered 1, 2, ..., NV. The only restriction
we place on the ordering is that variables corresponding to
the same point be numbered consecutively, and that their
corresponding unknown numberings be increasing. (That is, if
unknowns iu_1 < iu_2 < ... < iu_n are all defined at a point
ip, then the variables corresponding to these are numbered
i, i+1, ..., i+n-1, respectively.) For a variable i, the
associated unknown is stored in iu(i), while the point
number is stored in ip(i). The vector iv is used to denote
the variables defined at each point. Due to the ordering
restriction noted above, the variables defined at point j are
numbered iv(j), iv(j)+1, ..., iv(j+1)-1. Note that this
allows for an arbitrary number of unknowns (including zero)
to be defined there. This allows for "point-wise" processing,
or completely separate processing. The matrix itself is then
stored in compressed skyline form as in scalar AMG codes, with
no further special consideration of the points or unknowns
involved (at least by the user).

Vectors and matrices in AMG are still dimensioned as in previous
Fortran versions of AMG.  Here, all coarse grid data is stored
after the fine grid data in the same contiguous chunk of memory.
This will be fixed eventually as we continue to migrate to a
full C-implementation of the code.

Since coarsening is not really predictable, the total dimensions
needed can be a matter of trial and error.  The following macros
are defined in `amg.h', and should be used to dimension matrix
and vector data-space.  If you need to change any of these values,
you will need to recompile the AMG library, then relink your driver
routine.

   #define  NDIMU(nv)  (4*nv)
   #define  NDIMP(np)  (4*np)
   #define  NDIMA(na)  (6*na)
   #define  NDIMB(na)  (3*na)

The above are somewhat conservative.  The following are rough
rules of thumb for setting these values.  However, these
approximations may be overly optimistic and problem dependent.
You'll get a better idea when you run some tests on particular types
of problems.

   NDIMU - Set to 2*nv
   NDIMP - Set to 2*np
   NDIMA - Set to 3*number of nonzeroes in fine grid matrix
   	   (i.e., ndima = 3*ia(nv+1))
   NDIMB - Try ia(nv+1)/2. This is used to dimension interpolation
   	   storage. For small fine-grid stencils (like finite
   	   differences) a larger value may be needed.

For testing, you can overestimate these to avoid error conditions.

-----------------------------------------------------------------

II. Compiling the code

-----------------------------------------------------------------

III. Using AMG

The following C-calls define the basic interface for AMG (see
Section IV for information on the Fortran interface to AMG).  Here,
we assume that the matrix A and the vectors u and f have already
been initialized (see Appendix A below for details on initializing
these variables).

   Matrix  *A;
   Vector  *u, *f;
   void    *data;

   .
   .
   .

   /* get default data for an AMG run */
   data = amg_Initialize(NULL);

   /* call the AMG setup phase */
   amg_Setup(A, data);

   /* call the AMG solver phase */
   amg_Solve(u, f, tol, data);

   /* free up AMG data */
   amg_Finalize(data);

The call `amg_Initialize' returns a pointer to a "data" structure
which contains information needed by AMG such as parameter values.
The AMG setup phase is executed by `amg_Setup'.  This routine sets
up all of the AMG components such as coarse grids and intergrid
transfer operators.  The routine `amg_Solve' actually does the
multigrid cycling until either the relative residual is less than
some tolerance, `tol', or the max number of iterations has been
reached.  The `amg_Setup' and `amg_Solve' routines may be called
more than once.  For example, one may want to do several solves
for different right-hand-sides within a nonlinear loop without
re-doing the setup phase.  Finally, `amg_Finalize' frees up all
of the memory allocated by the AMG routines.

The above set of calls make up the minimum number of calls needed to
to run AMG.  In this situation, AMG is run with a set of "default"
parameters (see Section ? for a list of the default parameter settings).
Many of these parameters can be changed by the user to tailor an AMG
run to his or her needs.  These parameters are set by making calls to
one or more `amg_Set' routines between the `amg_Initialize' and
`amg_Solve' calls above.  The `amg_Set' routines are described in
detail in the following sections.


1. Changing the setup phase parameters.

The following routines are used to change the input parameters
associated with the setup phase.

   void  amg_SetLevMax((int) levmax, (void *) data)

      Sets the maximum number of levels.

   void  amg_SetNCG((int) ncg, (void *) data)

      Sets ncg, the type of coarsening to use.  ncg has 5 digits:

      1st digit -- idep   used to specify dependent coarsening
     
     			  1 - separate coarsening for unknowns
     
     			  2 - coarsen according to one unknown
     			      (set by second digit, idun).
     
     			  3 - fully coupled point coarsening
     
     			  Note: This determines the definition
     			  of the coarsening indicator array
     			  icdep. Other options can be added in
     			  the routine setdep, or can be passed
     			  in by reading icdep from the data file.
     
      2nd digit -- idun   driving unknown for dependent coars-
     			  ening. Only used when idep=2.
     
      3rd digit -- ifcg   sets way to force c-points before
     			  the coloring algorithm is used.
     			  0 - no points are forced
     			  1 - predefined c-points used.
     
      4th digit -- itst   sets the criterion f-points must meet.
     			  after coloring, resulting f-points are
     			  tested against this criterion.
     			  0 - no test is performed.
     			  1 - standard test (matrix weights)
     			  2 - standard test (number of connection
     
      5th digit -- iact   defines action taken for points not
     			  passing the f-point test.
     			  0 - no action taken.
     			  1 - the points not passing the test
     			      are re-colored.
     			  2 - the action is left to the test
     			      routine

   void  amg_SetECG((double) ecg, (void *) data)

      Sets ecg, strength of strong connection.

   void  amg_SetNWT((int) nwt, (void *) data)

      Sets nwt, the method for defining interpolation weights.
      nwt has 3 digits:

      1st digit -- iwts   sets the method for defining the
     			  interpolation weights to be used.
     			  0 - no weights are assigned.
     			  1 - equal weights are assigned.
     			  2 - standard method.
     			  3 - iterative weight definition
     			  4 - weights assigned in ftest &
     			      stored in a+. move into b.
     			  *** (Note: No weights computed
     			      in ftest1 or ftest2.)
     
      2nd, 3rd digits     remainder of digits. meaning depends
     			  on the value of iwts

   void  amg_SetEWT((double) ewt, (void *) data)

      Sets ewt, the parameter for specifying F-F stencil "overlap".

   void  amg_SetNSTR((int) nstr, (void *) data)

      Sets nstr, definition of strong connection.
      nstr has 3 digits:

      1st digit -- istr   sets definition of strong connection
     			  1 - direct strong connections used
     			  2 - long range connections used
     			  3 - long range connections used
     			      counting choice of 2nd order
     
      2nd digit -- isort  determines row sort.
     			  0 - strong connections determined
     			      by absolute value.
     			  1 - strong connections determined
     			      by sign of diagonal entry.


2. Changing the solver phase parameters.

The following routines are used to change the input parameters
associated with the solver phase.

   void  amg_SetNCyc((int) ncyc, (void *) data)

      Sets number and type of cycles.

      1st digit -- ivstar Specifies V* cycles if desired.
     			  1 - No V* cycle
     			  2 - Use V* cycle (this can accelerate
     			      slow convergence of symmetric
     			      problems at little extra cost)
     
      2nd digit -- ifcycl Specifies F-cycle usage.
     			  0 - No F-cycle
     			  1 - Uses an F-cycle (can also help
     			      accelerate convergence when slow.)
     
      ncycle (remaining digits) give number of cycles performed.

   void  amg_SetMU((int *) mu, (void *) data)

      Sets mu, the type of cycling to use for each level.
      mu(k) tells the number of cycles to use on level k+1 before
      interpolating and correcting the level k solution. All
      mu(k)'s set to 1 specifies V-cycles, 2 specifies W-cycles,
      etc. Useful for isolating levels with slow convergence.

   void  amg_SetNTRLX((int *) ntrlx, (void *) data)
   void  amg_SetIPRLX((int *) iprlx, (void *) data)
   void  amg_SetIERLX((int *) ierlx, (void *) data)
   void  amg_SetIURLX((int *) iurlx, (void *) data)

      Sets relaxation parameters, ntrX, iprX, ierX, and iurX (where X
      stands for f, d, u or c).  These parameters specify the number
      and type of relaxation to be performed on the fine level (f),
      when going from fine to coarser levels (d), coarse to fine
      levels (u), and on the coarsest level (c).  A full sweep can be
      made up of several partial sweeps (for example, relaxation only
      over C or F points, or over a specific unknown).

      ntrX  - Number & type of relaxation.
      	       1st digit -- nrelax - number of such sweeps to perform
      	       Remaining digits (together with iprX, ierX and iurX) define
      	       partial sweeps. The l'th digit of each together define the
      	       l'th partial sweep. Denote these by ntr, ipr, ier and iur.
      
      	       ntr - Type of relaxation sweep.
      		     1 - Usual Gauss-Seidel
      		     2 - Kaczmarz
      		     3 - Point (collective) Gauss-Seidel
      		     8 - Normalization (addition of a constant to get
      			 sum of specified variables equal to zero. Useful
      			 for singular matrices).
      		     9 - Direct solution (over specified variables). Used
      			 on coarsest level.
      
      	       ipr - Type of "points" to be relaxed.
      		     1 - F-variables only
      		     2 - All variables (C or F)
      		     3 - C-variables only.
      
      		     Note: when used with "point"  Gauss-Seidel, this will
      		     base its decision on whether or not to relax a point
      		     on whether the first variable there is a C or an F
      		     variable.
      
      	       ier - Equation type (which unknown) to be relaxed.
      	       iur - Unknown type to be relaxed. In the current code, these
      		     two mean the same thing, and should be set to the same
      		     value.
      
      		     ier=iur=n - (with n<=nu) means relax the variables
      				 corresponding to unknown n.
      
      		     ier=iur=9 - relax all unknowns.
      
      Example:   ntrf = 2118
     	    	 iprf =  312
     	    	 ierf =  991
     	    	 iurf =  991

      This example specifies two sweeps, each consisting of three partial
      sweeps. The first partial sweep is standard Gauss-Seidel over all
      C-variables (of all unknown types). The second specifies relaxation
      over F-variables (again of all unknown types). The third says to
      normalize the first unknown.
      
      Standard values used depend on the type of coarsening used.
      Typically, when independent coarsening is used (first digit of
      ncg=1), we use:
      
 	 ntrf=111  ntrd=111  ntru=111  ntrc=19
 	 iprf= 31  iprd= 31  ipru= 31  iprc= 2
 	 ierf= 99  ierd= 99  ieru= 99  ierc= 9
 	 iurf= 99  iurd= 99  iuru= 99  iurc= 9
      
      This is standard C/F relaxation, and direct solution on the coarsest
      level. When point-coarsening is used (for example when the first
      digit of ncg is 3), then we use the collective (point-wise) C/F
      relaxation:
      
 	 ntrf=133  ntrd=133  ntru=133  ntrc=19
 	 iprf= 31  iprd= 31  ipru= 31  iprc= 2
 	 ierf= 99  ierd= 99  ieru= 99  ierc= 9
 	 iurf= 99  iurd= 99  iuru= 99  iurc= 9


3. Getting output from AMG.

The following routine is used to log AMG setup and solve information
to an output file.

   void  amg_SetLogging((int) ioutdat, (char *) log_file_name, (void *) data)

      The value of ioutdat determines the amount of logging information
      to print out.  If log_file_name is NULL, the default name is used.
      otherwise, output is written to log_file_name.

   	 0 = no logging
   	 1 = log residual and relative residual after each V-cycle, and
             log average rate of convergence, complexity values
   	 2 = log matrix and interpolation statistics for each level
   	 3 = log information for ioutdat = 1 & 2



4. Changing the problem parameters.

The following routines are used to change the input parameters
associated with the problem.

   void  amg_SetNumUnknowns((int) num_unknowns, (void *) data)

      Sets the number of unknowns.

   void  amg_SetNumPoints((int) num_points, (void *) data)

      Sets the number of points.

   void  amg_SetIU((int *) iu, (void *) data)

      Sets array iu.  iu(i) is the unknown corresponding to variable i.
      Dimension is ndimu.

   void  amg_SetIP((int *) ip, (void *) data)

      Sets array ip.  ip(i) is the point corresponding to variable i.
      Dimension is ndimu.

   void  amg_SetIV((int *) iv, (void *) data)

      Sets array iv.  iv(j) points to the first variable defined at point j.
      (Remember that all variables defined at a point are
      numbered consecutively, but that the number of variables
      defined at a point can be arbitrary (0 through num_unknowns).
      Thus the variables at point j are numbered iv(j), iv(j)+1,...,
      iv(j+1)-1.)  NOTE: iv(np+1) must be defined as nv+1.
      Dimension is ndimp.

   void  amg_SetXP((double *) xp, (void *) data)
   void  amg_SetYP((double *) yp, (void *) data)
   void  amg_SetZP((double *) zp, (void *) data)

      Sets arrays xp, yp, and zp.  These are point coordinates (used
      for graphic output only at this time).
      Dimension is ndimp.


-----------------------------------------------------------------

IV.   Fortran interface

The Fortran interface is the same as the C interface except for
the following:

   1. Names are all lower case.
   2. Type `int' is of type `integer' in Fortran call.
   3. Type `double' is of type `real' in Fortran call.
   4. Type `int *' is of type `integer (*)' in Fortran call.
   5. Type `double *' is of type `real (*)' in Fortran call.
   6. Type `char *' is of type `character*(*)' in Fortran call.
   7. Type `void *' is of type `integer' in Fortran call.
   8. Returned variables are listed first in the Fortran argument list.

Example 1:

     integer data
     call amg_initialize(data, 0)

Example 2:

     integer data
     call amg_setlogging(1, 'my.log.file', data)

Example 3:

     integer iu(*)
     integer data
     call amg_setiu(iu, data)


-----------------------------------------------------------------

APPENDIX A.  Matrix and Vector formats.

The Matrix and Vector structures are as follows (this is subject to
change in future parallel versions of AMG):

   typedef struct
   {
      double  *data;
      int     *ia;
      int     *ja;
      int      size;
    
   } Matrix;
   
   typedef struct
   {
      double  *data;
      int      size;
    
   } Vector;


The data within these structures may be accessed with the following
accessor macros:

   #define MatrixData(matrix)      ((matrix) -> data)
   #define MatrixIA(matrix)        ((matrix) -> ia)
   #define MatrixJA(matrix)        ((matrix) -> ja)
   #define MatrixSize(matrix)      ((matrix) -> size)
   
   #define VectorData(vector)      ((vector) -> data)
   #define VectorSize(vector)      ((vector) -> size)

To create and destroy a Matrix and Vector structure, one generally
does the following:

   Matrix  *A;
   Vector  *v;
   double  *a_data;
   double  *v_data;
   int     *ia, *ja;
   int      size;
   
   ...
   
   /* allocate a_data, ia, ja, and v_data */
   
   /* initialize a_data, ia, ja, and v_data */
   
   /* construct A and v */
   A = NewMatrix(a_data, ia, ja, size);
   v = NewVector(v_data, size);
   
   /* destroy A and v */
   FreeMatrix(A);
   FreeVector(v);

Matrix storage is in Yale Sparse Matrix Package form (basically
a compressed skyline form). The dimension of MatrixIA is NDIMV.
The dimension of MatrixData and MatrixJA is NDIMA.  Remember that
MatrixIA(num_variables+1) must point to the first location of
MatrixData beyond the stored matrix.

Vector storage is straightforward with the dimension of VectorData
given by NDIMU.

Example:

    ( A      A      0      0      0  ) ( u  )       ( f  )
    (  11     12                     ) (  1 )       (  1 )
    (                                ) (    )       (    )
    ( A      A      A      0      A  ) ( u  )       ( f  )
    (  21     22     23            25) (  2 )       (  2 )
    (                                ) (    )       (    )
    ( 0      A      A      A      0  ) ( u  )   =   ( f  )
    (         32     33     34       ) (  3 )       (  3 )
    (                                ) (    )       (    )
    ( 0      0      A      A      A  ) ( u  )       ( f  )
    (                43     44     45) (  4 )       (  4 )
    (                                ) (    )       (    )
    ( A      0      0      0      A  ) ( u  )       ( f  )
    (  51                          55) (  5 )       (  5 )
    (                                ) (    )       (    )

    We have num_variables = 5 and na = 14

    The different user-supplied arrays look like this:

MatrixData:  A   A   A   A   A   A   A   A   A   A    A    A    A    A
              11  12  22  21  23  25  33  32  34  44   43   45   55   51

index (i):   1   2   3   4   5   6   7   8   9   10   11   12   13   14
             ^       ^               ^           ^              ^
             |    ___|               |           |              |
             |	 |   ________________|           |              |
             |	 |   |   ________________________|              |
             |	 |   |   |   ___________________________________|
             |	 |   |   |   |   _________________________________________
             |	 |   |   |   |   |
MatrixIA :   1   3   7  10  13  15
index (i):   1   2   3   4   5   6


MatrixJA : 1   2   2   1   3   5   3   2   4   4   3   5   5   1
index (j): 1   2   3   4   5   6   7   8   9   10  11  12  13  14
                   *               *           *           *
           '*' denotes the beginning of pointers to next equation

VectorData:  u   u   u   u   u
              1   2   3   4   5

           With these values the 3rd equation reads as follows:
           ia = MatrixIA(A)
           ja = MatrixJA(A)
           i  = 3
           j1 = ia(i)                = 7
           j2 = ia(i+1) - 1 = 10 - 1 = 9

           A(7) u(ja(7)) + A(8) u(ja(8)) + A(9) u(ja(9) = f
                                                           3
           A    u        +  A   u        + A    u       = f
            33   3           32  2          34   4         3

