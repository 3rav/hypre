-----------------------------------------------------------------

DOCUMENTATION FOR AMG

1. GENERAL DESCRIPTION
2. COMPILING AND RUNNING THE EXAMPLE DRIVERS
3. USING AMG
4. FORTRAN INTERFACE
5. DEFAULT PARAMETERS FOR AMG

APPENDIX A. Matrix and Vector formats.


-----------------------------------------------------------------

1. GENERAL DESCRIPTION

This version of AMG is a C/Fortran code based on the original
all-Fortran code, AMGS01 (AMG for systems).  Much of the documentation
below is from the User's Manual for that code.  The main differences
are the interface, and the use of dynamic memory allocation.

AMGS01 is a version of AMG meant to be applied to "systems"
problems, that is, linear systems in which approximations to
a number of different functions (e.g., pressure, components of
velocity or displacement, etc.) are being approximated.
The code was designed to be fairly general. An arbitrary
number of different functions can be approximated (although
this is somewhat artificially limited to 5 (or 10) in the
current code). Each such function is called an UNKNOWN. Each
unknown is defined at some set of POINTS (generally a real
point in the physical domain). The sets of points for each
unknown can be the same (as in a vertex-centered discretization,
for example), or disjoint (as in a staggered grid), or
a combination. That is, a set of points, 1, 2, ..., NP is
defined, and at each point (possibly different for each point)
some subset of the unknowns (which we denote by 1, 2, ..., NU)
is defined. Each such point/unknown pair is associated with
a VARIABLE (one of the quantities to be approximated). The
variables are numbered 1, 2, ..., NV. The only restriction
we place on the ordering is that variables corresponding to
the same point be numbered consecutively, and that their
corresponding unknown numberings be increasing. (That is, if
unknowns iu_1 < iu_2 < ... < iu_n are all defined at a point
ip, then the variables corresponding to these are numbered
i, i+1, ..., i+n-1, respectively.) For a variable i, the
associated unknown is stored in iu(i), while the point
number is stored in ip(i). The vector iv is used to denote
the variables defined at each point. Due to the ordering
restriction noted above, the variables defined at point j are
numbered iv(j), iv(j)+1, ..., iv(j+1)-1. Note that this
allows for an arbitrary number of unknowns (including zero)
to be defined there. This allows for "point-wise" processing,
or completely separate processing. The matrix itself is then
stored in compressed skyline form as in scalar AMG codes, with
no further special consideration of the points or unknowns
involved (at least by the user).

Vectors and matrices in AMG are still dimensioned as in previous
Fortran versions of AMG.  Here, all coarse grid data is stored
after the fine grid data in the same contiguous chunk of memory.
This will be fixed eventually as we continue to migrate to a
full C-implementation of the code.

Since coarsening is not really predictable, the total dimensions
needed can be a matter of trial and error.  The following macros
are defined in `amg.h', and should be used to dimension matrix
and vector data-space.  If you need to change any of these values,
you will need to recompile the AMG library, then relink your driver
routine. Here `na' is taken to mean the number of nonzero coefficients 
in the matrix A.

   #define  NDIMU(nv)  (4*nv)
   #define  NDIMP(np)  (4*np)
   #define  NDIMA(na)  (6*na)
   #define  NDIMB(na)  (3*na)

The above are somewhat conservative.  The following are rough
rules of thumb for setting these values.  However, these
approximations may be overly optimistic and problem dependent.
You'll get a better idea when you run some tests on particular types
of problems.

   NDIMU - Set to 2*nv
   NDIMP - Set to 2*np
   NDIMA - Set to 3*number of nonzeroes in fine grid matrix
   	   (i.e., ndima = 3*ia(nv+1))
   NDIMB - Try ia(nv+1)/2. This is used to dimension interpolation
   	   storage. For small fine-grid stencils (like finite
   	   differences) a larger value may be needed.

For testing, you can overestimate these to avoid error conditions.


-----------------------------------------------------------------

2. COMPILING AND RUNNING THE EXAMPLE DRIVERS



2.1. COMPILING THE AMG LIBRARY

Compiling the library may require some configuration.  First,
cd into the `src' subdirectory.  The `config.default' file
contains the default configuration options used to build the library.
The remaining `config.*' files override the default configurations
for building the library on different platforms.  Use these as
examples for creating your own configuration file.

Create a config file (say `config.mine') with no lines in it.
Then, type:

   build -arch config.mine

If the library builds, then you don't need to do any configuring.
Otherwise, use the example configuration files as guides to change
your `config.mine' file appropriately.  Any of the variables
defined in the `config.defaults' file may be overridden in your
`config.mine' file.

To install, type:

   build -arch config.mine install

This will also build the library if it hasn't already been built.
The default is to install the library in a `lib' subdirectory
of the `amg' directory, and to install the include files in an
`include' subdirectory.  The `AMG_LIB_DIR' and `AMG_INCLUDE_DIR'
configuration variables may be used to change location of the
installation.


2.2. COMPILING THE EXAMPLE DRIVERS

The example drivers are in the `examples' subdirectory.  Several
example makefiles (`Makefile.*') are included as guides for
linking to the AMG library.  Compiling the example drivers is
the most difficult configuration challenge, mainly because the
current version of AMG consists of both C and Fortran code.

Copy one of the `Makefile.*' files to `Makefile'.  Then, say

   make

Modify the configuration variables in the makefile until the
drivers compile and link correctly to the AMG library.


2.3. RUNNING THE EXAMPLE DRIVERS

Two examples of Fortran drivers have been included in the `examples'
directory.  The compilation of the two drivers, `amg_fdrive' and
`amg_fdrive2' is described in the previous paragraph.

To run either of the drivers, simply type its name.  For example,
typing  either `amg_fdrive' or `amg_fdrive2' will produce the 
on-screen output:

 Setup error flag =   0
 Solve error flag =   0

which indicates that both the setup and the solve phases of AMG ran
successfully.  The meaning of the error flag values is discussed below.

In addition, the drivers (as delivered) will create output log files 
named `AMG.runlog' or `AMG2.runlog', depending on which driver was run. 
These files contain the user selected parameters for running AMG, the
matrix statistics of the operators on the various multigrid levels, 
and the output information, such as the convergence rate and the relative
residuals after each V-cycle. A few comments are included below about
each of the examples.


2.3a)  amg_fdrive.f

The driver `amg_fdrive.f' is designed to illustrate the simplest use of AMG.
The code reads in a matrix, right-hand side, and an initial guess. The
matrix supplied is a 500x500 scalar diffusion problem, set on an unstructured
grid.  The code uses default values for all variables except the stopping
tolerance (for which there is no default) and the `ioutdat' parameter, which
is set to `3' by the routine `amg_setlogging' and instructs the code to 
generate an output log (`AMG.runlog'). The default value for `ioutdat' is 0,
in which case AMG returns a vector `u' as a solution and the error flag,
but yields no output logfile. Thus, except for setting the logfile parameter,
the code `amg_fdrive.f' consists of the bare minimum: the amg_initialize,
amg_setup, amg_solve, and amg_finalize calls.

A point of interest about amg_fdrive.f: since it was designed to illustrate 
the most basic use of AMG the default parameters have not been tweaked.  The
defaults are considered the `best' choices on average.  For the most part, 
changes in parameters do not yield dramatic differences in performance, but
occasionally they do.  For example, on the particular problem delivered with
`amg_fdrive.f', including iterative weight definition by inserting the code

      call amg_setnwt(31111,data)

prior to the amg_Setup call will reduce the overall convergence rate from
0.44 to 0.19 and the number of V-cycles needed to reach the stopping 
criterion from 14 to 8.  NOTE: In this simple driver, changing one of the
parameters in this fashion means adding a `call amg_setXXX' line, which
necessitates recompiling prior to running the code.


2.3b) amg_fdrive2.f

The driver `amg_fdrive2.f' is designed to illustrate a more complicated 
situation, both in terms of the problem and in terms of the operation of
the code.  

The operator is a 915x915 matrix, and represents a coupled system of
3 unknown functions, each defined at each of 305 points on a highly
unstructured grid.  The underlying physics is an elasticity problem. 

In `amg_fdrive2.f' many of the parameters are set, overriding the defaults. 
The values of these parameters are read in from a control file, 
`AMG2.in.control' and set via `amg_setXXX' calls prior to calling `amg_setup'. 
This means that to experiment with altering the parameters, new values 
need only be placed in the control file, and recompiling the code is not 
required.

As with `amg_fdrive.f', the matrix, right-hand side, and initial guess are
read in from a file.  The values of the index arrays `iu', `iv', and `ip',
necessary because the problem is a system, are set to the default values
by amg_setup (if some of the unknowns were defined only at some points it
would be necessary to provide that information using the `amg_setiu',
`amg_setip', and `amg_setiv' commands).


2.3c) THE ERROR FLAG AND STOPPING CRITERION

The program `amg_Solve' is built to terminate under two different criteria.
The first is a stopping tolerance, applied to the relative residual.  That
is, if 

                      ||f-Au|| / ||f||  < tol

the iteration stops and returns `u' as the solution.  The tolerance `tol'
is an external argument, and hence there is no `amg_Set' routine for
adjusting it.  It should be set in the driver and is passed to the solver
in the calling statement `call amg_Solve(isverr,u,f,nv,tol,data)'. The 
value of `tol' can be set to zero, in which case the iteration will never
stop due to the stopping tolerance.  Note that if the right-hand side is 
zero the relative residual calculation will produce an overflow whenever
it is calculated. As the relative residual is used only for the stopping
criterion, this should present no problem on most hardwares.

The second stopping criterion is an iteration limit.  The variable `ncyc' 
sets a limit on the number of V-cycles AMG is allowed to perform. 

The value of the returned error flags will be `0' if the code has 
run successfully and if solver is halted by the relative residual stopping
criterion. If the solver error flag has a value of `1' then the maximum
iteration count was reached before the relative residual is smaller
than the stopping tolerance.

Several other values are possible for the error flags on both routines, but 
should not, in general, occur.  If the setup error flag returns a 1, 2, or 3,
the parameters `ndima', `ndimb', or `ndimu' (respectively) may need to be 
increased.  See section 1 of this guide. Any value of the setup error flag
other than 0, 1, 2, or 3, and any value of the solver error flag other than
0 or 1 should be reported to the supplier of the AMG code.


-----------------------------------------------------------------

3. USING AMG

The following C-calls define the basic interface for AMG (see
Section 4 for information on the Fortran interface to AMG).  Here,
we assume that the matrix `A', the vectors `u' and `f', and the stopping
tolerance `tol' have already been initialized (see Appendix A below for 
details on initializing these variables).

   Matrix  *A;
   Vector  *u, *f;
   void    *data;
   double   tol
   int      setup_err_flag, solve_err_flag

   .
   .
   .

   /* get default data for an AMG run */
   data = amg_Initialize(NULL);

   /* call the AMG setup phase */
   setup_err_flag = amg_Setup(A, data);

   /* call the AMG solver phase */
   solve_err_flag = amg_Solve(u, f, tol, data);

   /* free up AMG data */
   amg_Finalize(data);

The call `amg_Initialize' returns a pointer to a "data" structure
which contains information needed by AMG such as parameter values.
The AMG setup phase is executed by `amg_Setup'.  This routine sets
up all of the AMG components such as coarse grids and intergrid
transfer operators.  The routine `amg_Solve' actually does the
multigrid cycling until either the relative residual is less than
some tolerance, `tol', or the max number of iterations has been
reached.  The `amg_Setup' and `amg_Solve' routines may be called
more than once.  For example, one may want to do several solves
for different right-hand-sides within a nonlinear loop without
re-doing the setup phase.  Finally, `amg_Finalize' frees up all
of the memory allocated by the AMG routines.

The above set of calls make up the minimum number of calls needed to
to run AMG.  In this situation, AMG is run with a set of "default"
parameters (see Section 5 for a list of the default parameter settings).
Many of these parameters can be changed by the user to tailor an AMG
run to his or her needs.  These parameters are set by making calls to
one or more `amg_Set' routines between the `amg_Initialize' and
`amg_Solve' calls above.  The `amg_Set' routines are described in
detail in the following sections.


3.1. CHANGING THE SETUP PHASE PARAMETERS

The following routines are used to change the input parameters
associated with the setup phase.

   void  amg_SetLevMax((int) levmax, (void *) data)

      Sets the maximum number of levels.

   void  amg_SetNCG((int) ncg, (void *) data)

      Sets ncg, the type of coarsening to use.  ncg has 5 digits:

      1st digit -- idep   used to specify dependent coarsening
     
     			  1 - separate coarsening for unknowns
     
     			  2 - coarsen according to one unknown
     			      (set by second digit, idun).
     
     			  3 - fully coupled point coarsening
     
     			  Note: This determines the definition
     			  of the coarsening indicator array
     			  icdep. Other options can be added in
     			  the routine setdep, or can be passed
     			  in by reading icdep from the data file.
     
      2nd digit -- idun   driving unknown for dependent coars-
     			  ening. Only used when idep=2.
     
      3rd digit -- ifcg   sets way to force c-points before
     			  the coloring algorithm is used.
     			  0 - no points are forced
     			  1 - predefined c-points used.
     
      4th digit -- itst   sets the criterion f-points must meet.
     			  after coloring, resulting f-points are
     			  tested against this criterion.
     			  0 - no test is performed.
     			  1 - standard test (matrix weights)
     			  2 - standard test (number of connection
     
      5th digit -- iact   defines action taken for points not
     			  passing the f-point test.
     			  0 - no action taken.
     			  1 - the points not passing the test
     			      are re-colored.
     			  2 - the action is left to the test
     			      routine

   void  amg_SetECG((double) ecg, (void *) data)

      Sets ecg, strength of strong connection.

   void  amg_SetNWT((int) nwt, (void *) data)

      Sets nwt, the method for defining interpolation weights.
      nwt has 3 digits:

      1st digit -- iwts   sets the method for defining the
     			  interpolation weights to be used.
     			  0 - no weights are assigned.
     			  1 - equal weights are assigned.
     			  2 - standard method.
     			  3 - iterative weight definition
     			  4 - weights assigned in ftest &
     			      stored in a+. move into b.
     			  *** (Note: No weights computed
     			      in ftest1 or ftest2.)
     
      2nd, 3rd digits     remainder of digits. meaning depends
     			  on the value of iwts

   void  amg_SetEWT((double) ewt, (void *) data)

      Sets ewt, the parameter for specifying F-F stencil "overlap".

   void  amg_SetNSTR((int) nstr, (void *) data)

      Sets nstr, definition of strong connection.
      nstr has 3 digits:

      1st digit -- istr   sets definition of strong connection
     			  1 - direct strong connections used
     			  2 - long range connections used
     			  3 - long range connections used
     			      counting choice of 2nd order
     
      2nd digit -- isort  determines row sort.
     			  0 - strong connections determined
     			      by absolute value.
     			  1 - strong connections determined
     			      by sign of diagonal entry.


3.2. CHANGING THE SOLVER PHASE PARAMETERS

The following routines are used to change the input parameters
associated with the solver phase.

   void  amg_SetNCyc((int) ncyc, (void *) data)

      Sets number and type of cycles.

      1st digit -- ivstar Specifies V* cycles if desired.
     			  1 - No V* cycle
     			  2 - Use V* cycle (this can accelerate
     			      slow convergence of symmetric
     			      problems at little extra cost)
     
      2nd digit -- ifcycl Specifies F-cycle usage.
     			  0 - No F-cycle
     			  1 - Uses an F-cycle (can also help
     			      accelerate convergence when slow.)
     
      ncycle (remaining digits) give number of cycles performed.

   void  amg_SetMU((int *) mu, (void *) data)

      Sets mu, the type of cycling to use for each level.
      mu(k) tells the number of cycles to use on level k+1 before
      interpolating and correcting the level k solution. All
      mu(k)'s set to 1 specifies V-cycles, 2 specifies W-cycles,
      etc. Useful for isolating levels with slow convergence.

   void  amg_SetNTRLX((int *) ntrlx, (void *) data)
   void  amg_SetIPRLX((int *) iprlx, (void *) data)
   void  amg_SetIERLX((int *) ierlx, (void *) data)
   void  amg_SetIURLX((int *) iurlx, (void *) data)

      Sets relaxation parameters, ntrX, iprX, ierX, and iurX (where X
      stands for f, d, u or c).  These parameters specify the number
      and type of relaxation to be performed on the fine level (f),
      when going from fine to coarser levels (d), coarse to fine
      levels (u), and on the coarsest level (c).  A full sweep can be
      made up of several partial sweeps (for example, relaxation only
      over C or F points, or over a specific unknown).

      ntrX  - Number & type of relaxation.
      	       1st digit -- nrelax - number of such sweeps to perform
      	       Remaining digits (together with iprX, ierX and iurX) define
      	       partial sweeps. The l'th digit of each together define the
      	       l'th partial sweep. Denote these by ntr, ipr, ier and iur.
      
      	       ntr - Type of relaxation sweep.
      		     1 - Usual Gauss-Seidel
      		     2 - Kaczmarz
      		     3 - Point (collective) Gauss-Seidel
      		     8 - Normalization (addition of a constant to get
      			 sum of specified variables equal to zero. Useful
      			 for singular matrices).
      		     9 - Direct solution (over specified variables). Used
      			 on coarsest level.
      
      	       ipr - Type of "points" to be relaxed.
      		     1 - F-variables only
      		     2 - All variables (C or F)
      		     3 - C-variables only.
      
      		     Note: when used with "point"  Gauss-Seidel, this will
      		     base its decision on whether or not to relax a point
      		     on whether the first variable there is a C or an F
      		     variable.
      
      	       ier - Equation type (which unknown) to be relaxed.
      	       iur - Unknown type to be relaxed. In the current code, these
      		     two mean the same thing, and should be set to the same
      		     value.
      
      		     ier=iur=n - (with n<=nu) means relax the variables
      				 corresponding to unknown n.
      
      		     ier=iur=9 - relax all unknowns.
      
      Example:   ntrf = 2118
     	    	 iprf =  312
     	    	 ierf =  991
     	    	 iurf =  991

      This example specifies two sweeps, each consisting of three partial
      sweeps. The first partial sweep is standard Gauss-Seidel over all
      C-variables (of all unknown types). The second specifies relaxation
      over F-variables (again of all unknown types). The third says to
      normalize the first unknown.
      
      Standard values used depend on the type of coarsening used.
      Typically, when independent coarsening is used (first digit of
      ncg=1), we use:
      
 	 ntrf=111  ntrd=111  ntru=111  ntrc=19
 	 iprf= 31  iprd= 31  ipru= 31  iprc= 2
 	 ierf= 99  ierd= 99  ieru= 99  ierc= 9
 	 iurf= 99  iurd= 99  iuru= 99  iurc= 9
      
      This is standard C/F relaxation, and direct solution on the coarsest
      level. When point-coarsening is used (for example when the first
      digit of ncg is 3), then we use the collective (point-wise) C/F
      relaxation:
      
 	 ntrf=133  ntrd=133  ntru=133  ntrc=19
 	 iprf= 31  iprd= 31  ipru= 31  iprc= 2
 	 ierf= 99  ierd= 99  ieru= 99  ierc= 9
 	 iurf= 99  iurd= 99  iuru= 99  iurc= 9


3.3. GETTING OUTPUT FROM AMG

The following routine is used to log AMG setup and solve information
to an output file.

   void  amg_SetLogging((int) ioutdat, (char *) log_file_name, (void *) data)

      The value of ioutdat determines the amount of logging information
      to print out.  If log_file_name is NULL, the default name is used.
      otherwise, output is written to log_file_name.

   	 0 = no logging
   	 1 = log residual and relative residual after each V-cycle, and
             log average rate of convergence, complexity values
   	 2 = log matrix and interpolation statistics for each level
   	 3 = log information for ioutdat = 1 & 2


3.4. CHANGING THE PROBLEM PARAMETERS

The following routines are used to change the input parameters
associated with the problem.

   void  amg_SetNumUnknowns((int) num_unknowns, (void *) data)

      Sets the number of unknowns.

   void  amg_SetNumPoints((int) num_points, (void *) data)

      Sets the number of points.

   void  amg_SetIU((int *) iu, (void *) data)

      Sets array iu.  iu(i) is the unknown corresponding to variable i.
      Dimension is ndimu.

   void  amg_SetIP((int *) ip, (void *) data)

      Sets array ip.  ip(i) is the point corresponding to variable i.
      Dimension is ndimu.

   void  amg_SetIV((int *) iv, (void *) data)

      Sets array iv.  iv(j) points to the first variable defined at point j.
      (Remember that all variables defined at a point are
      numbered consecutively, but that the number of variables
      defined at a point can be arbitrary (0 through num_unknowns).
      Thus the variables at point j are numbered iv(j), iv(j)+1,...,
      iv(j+1)-1.)  NOTE: iv(np+1) must be defined as nv+1.
      Dimension is ndimp.

   void  amg_SetXP((double *) xp, (void *) data)
   void  amg_SetYP((double *) yp, (void *) data)
   void  amg_SetZP((double *) zp, (void *) data)

      Sets arrays xp, yp, and zp.  These are point coordinates (used
      for graphic output only at this time).
      Dimension is ndimp.


-----------------------------------------------------------------

4. FORTRAN INTERFACE

The Fortran interface is the same as the C interface except for
the following:

   1. Names are all lower case.
   2. Type `int' is of type `integer' in Fortran call.
   3. Type `double' is of type `real*8' in Fortran call.
   4. Type `int *' is of type `integer (*)' in Fortran call.
   5. Type `double *' is of type `real*8 (*)' in Fortran call.
   6. Type `char *' is of type `character*(*)' in Fortran call.
   7. Type `void *' is of type `integer' in Fortran call.
   8. Returned variables are listed first in the Fortran argument list.

The following Fortran calls define the basic interface for AMG (see
Section 3 for information on the C interface to AMG).  Here,
we assume that the matrix `A', the vectors `u' and `f', the number of
variables `nv', and the stopping tolerance `tol' have already been 
initialized (see Appendix A below for details on initializing these 
variables). Note also that the parameter statement is an example; different
problem sizes may require larger values for ndima and ndimu.  See section 1.

c---------------------------------------------
      parameter(ndima=600000,ndimu=250000)
      dimension A(ndima),JA(ndima),IA(ndimu),U(ndimu),F(ndimu)
      integer data
      real*8  tol
      integer nv
      integer isterr, isverr 

c     get default data for an AMG run 
      call amg_initialize(data,0)
  
c     call the AMG setup phase
      call amg_setup(isterr,a,ia,ja,nv,data)

c     call the AMG solver phase
      call amg_solve(isverr,u,f,nv,tol,data)
 
c     free up AMG data
      call amg_finalize(data)

c---------------------------------------------


4.1. CHANGING THE SETUP PHASE PARAMETERS

The setup phase parameters may be changed through the fortran interface 
using the calls:

      call amg_setlevmax(levmax, data)
      call amg_setncg(ncg, data)
      call amg_setecg(ecg, data)
      call amg_setnwt(nwt, data)
      call amg_setewt(ewt, data)
      call amg_setnstr(nstr, data)

Details as to the meaning of these parameters are given in section 3.
 

4.2. CHANGING THE SOLVE PHASE PARAMETERS

The solve phase parameters may be changed through the fortran interface 
using the calls:

      call amg_setncyc(ncyc, data)
      call amg_setmu(mu, data)
      call amg_setntrlx(ntrlx, data)
      call amg_setiprlx(iprlx, data)
      call amg_setierlx(ierlx, data)
      call amg_setiurlx(iurlx, data)

Details as to the meaning of these parameters are given in section 3.
 

4.3. GETTING OUTPUT FROM AMG

The following routine is used to log AMG setup and solve information
to an output file.

      call amg_setlogging(ioutdat, log_file_name, data)
 
Details as to the meaning of these parameters are given in section 3.

 
4.4. CHANGING THE PROBLEM PARAMETERS

The following routines are used to change the input parameters
associated with the problem.

      call amg_setnumunknowns(num_unknowns, data)
      call amg_setnumpoints(num_points, data)
      call amg_setiu(iu, data)
      call amg_setip(ip, data)
      call amg_setiv(iv, data)
      call amg_setxp(xp, data)
      call amg_setyp(yp, data)
      call amg_setzp(zp, data)

Details as to the meaning of these parameters are given in section 3.
 

-----------------------------------------------------------------

5. DEFAULT PARAMETERS FOR AMG

Below is a list of the default parameters included with the AMG 
code.  These parameters may be changed in accordance with the 
instructions in sections 3 and 4.


5.1. SETUP PHASE PARAMETER DEFAULTS


    Maximum number of levels:            25                    levmax
    Coarsening controls:                 30012   0.25          ncg, ecg
    Interpolation controls:              200     0.35          nwt, ewt
    Strong connection definition:        11                    nstr


5.2. SOLVER PHASE PARAMETER DEFAULTS

    Number and type of cycles:           1020                   ncyc
    W-cycling parameter:                 1 1 1 1 1 1 1 1 1 1    mu
    Relaxation Parameters:               133  133  133  19      ntr(f,d,u,c)
                                         31   31   13   2       ipr(f,d,u,c)
                                         99   99   99   9       ier(f,d,u,c)
                                         99   99   99   9       iur(f,d,u,c)

    Output flag:                         0                      ioutdat


5.3. PROBLEM PARAMETER DEFAULTS

   Number of unknowns                    1                      num_unknowns
   Number of points                      nv (# of variables)    num_points

   Pointers: iu, iv, ip                  if automatically set for one unknown:
                                         (example: 1 unknown, num_points=12)
                                         iu = {1,1,1,1,1,1,1,1,1,1,1,1}
                                         ip = {1,2,3,4,5,6,7,8,9,10,11,12}
                                         iv = {1,2,3,4,5,6,7,8,9,10,11,12}

   Pointers: iu, iv, ip                  if automatically set, m unknowns:
                                         (example: m=3, num_points=4)
                                         iu = {1,2,3,1,2,3,1,2,3,1,2,3}
                                         ip = {1,1,1,2,2,2,3,3,3,4,4,4}
                                         iv = {1,4,7,10}

   X,Y,Z data: xp, yp, zp                no default   


-----------------------------------------------------------------

APPENDIX A. MATRIX AND VECTOR FORMATS

The Matrix and Vector structures are as follows (this is subject to
change in future parallel versions of AMG):

   typedef struct
   {
      double  *data;
      int     *ia;
      int     *ja;
      int      size;
    
   } Matrix;
   
   typedef struct
   {
      double  *data;
      int      size;
    
   } Vector;


The data within these structures may be accessed with the following
accessor macros:

   #define MatrixData(matrix)      ((matrix) -> data)
   #define MatrixIA(matrix)        ((matrix) -> ia)
   #define MatrixJA(matrix)        ((matrix) -> ja)
   #define MatrixSize(matrix)      ((matrix) -> size)
   
   #define VectorData(vector)      ((vector) -> data)
   #define VectorSize(vector)      ((vector) -> size)

To create and destroy a Matrix and Vector structure, one generally
does the following:

   Matrix  *A;
   Vector  *v;
   double  *a_data;
   double  *v_data;
   int     *ia, *ja;
   int      size;
   
   ...
   
   /* allocate a_data, ia, ja, and v_data */
   
   /* initialize a_data, ia, ja, and v_data */
   
   /* construct A and v */
   A = NewMatrix(a_data, ia, ja, size);
   v = NewVector(v_data, size);
   
   /* destroy A and v */
   FreeMatrix(A);
   FreeVector(v);

Matrix storage is in Yale Sparse Matrix Package form (basically
a compressed skyline form). The dimension of MatrixIA is NDIMV.
The dimension of MatrixData and MatrixJA is NDIMA.  Remember that
MatrixIA(num_variables+1) must point to the first location of
MatrixData beyond the stored matrix.

Vector storage is straightforward with the dimension of VectorData
given by NDIMU.

Example:

    ( A      A      0      0      0  ) ( u  )       ( f  )
    (  11     12                     ) (  1 )       (  1 )
    (                                ) (    )       (    )
    ( A      A      A      0      A  ) ( u  )       ( f  )
    (  21     22     23            25) (  2 )       (  2 )
    (                                ) (    )       (    )
    ( 0      A      A      A      0  ) ( u  )   =   ( f  )
    (         32     33     34       ) (  3 )       (  3 )
    (                                ) (    )       (    )
    ( 0      0      A      A      A  ) ( u  )       ( f  )
    (                43     44     45) (  4 )       (  4 )
    (                                ) (    )       (    )
    ( A      0      0      0      A  ) ( u  )       ( f  )
    (  51                          55) (  5 )       (  5 )
    (                                ) (    )       (    )

    We have num_variables = 5 and na = 14

    The different user-supplied arrays look like this:

MatrixData:  A   A   A   A   A   A   A   A   A   A    A    A    A    A
              11  12  22  21  23  25  33  32  34  44   43   45   55   51

index (i):   1   2   3   4   5   6   7   8   9   10   11   12   13   14
             ^       ^               ^           ^              ^
             |    ___|               |           |              |
             |	 |   ________________|           |              |
             |	 |   |   ________________________|              |
             |	 |   |   |   ___________________________________|
             |	 |   |   |   |   _________________________________________
             |	 |   |   |   |   |
MatrixIA :   1   3   7  10  13  15
index (i):   1   2   3   4   5   6


MatrixJA : 1   2   2   1   3   5   3   2   4   4   3   5   5   1
index (j): 1   2   3   4   5   6   7   8   9   10  11  12  13  14
                   *               *           *           *
           '*' denotes the beginning of pointers to next equation

VectorData:  u   u   u   u   u
              1   2   3   4   5

           With these values the 3rd equation reads as follows:
           ia = MatrixIA(A)
           ja = MatrixJA(A)
           i  = 3
           j1 = ia(i)                = 7
           j2 = ia(i+1) - 1 = 10 - 1 = 9

           A(7) u(ja(7)) + A(8) u(ja(8)) + A(9) u(ja(9) = f
                                                           3
           A    u        +  A   u        + A    u       = f
            33   3           32  2          34   4         3

