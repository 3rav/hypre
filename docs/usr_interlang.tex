\chapter{Interoperability with Fortran}

%==========================================================================
\section{Calls to {\slshape hypre} from Fortran source code}

Fortran 77 subroutine arguments always pass copies of the argument addresses
on execution of the call.  This is referred to as call-by-address, or
call-by-reference.  In the called subroutine, the memory space at the
argument address can be altered.  The calling address, however, cannot be
altered.

C function parameters, on the other hand, are often directly copied upon
entry to the function.  These parameters do not have to be addresses.
This is referred to as call-by-value.  Altering the copied C parameter in the
called function has no effect on the parameter in the calling function.  So,
C essentially has more freedom than Fortran.  A pointer parameter in C can
achieve the same effect as call-by-reference, but all parameters do not have
to be pointers.

The simplicity of Fortran, and the flexibility of C, allow the languages to
interoperate.  However, portability might introduce complexities to
configuration of the interoperating codes.

Portability across DEC Compass, DEC Tera, and IBM ASCI-Blue platforms is
currently achieved with the specific Fortran-calling-C mapping: 

\vspace{0.2in}

\begin{tabular}{lcl}

\underline{calling Fortran argument type} & &
\underline{called C function parameter type} \\
                              &                   &   \\
\hspace{0.1in} (addr of) \verb+integer*8+        & $\longrightarrow$ &
\hspace{0.5in} \verb+long int *+ \\
\hspace{0.1in} (addr of) \verb+integer+          & $\longrightarrow$ &
\hspace{0.5in} \verb+int *+ \\
\hspace{0.1in} (addr of) \verb+character+        & $\longrightarrow$ &
\hspace{0.5in} \verb+char *+ \\
\hspace{0.1in} (addr of) \verb+double precision+ & $\longrightarrow$ &
\hspace{0.5in} \verb+double *+ \\

\end{tabular}

\vspace{0.2in}

In particular, on DEC Compass, DEC Tera, and IBM ASCI-Blue, C-type
\verb+long int *+ points to a space that can hold an address, a space
which happens to be the size of that allocated by a Fortran
\verb+integer*8+ declaration.
In orther words, C can hold an address to anything in a \verb+long int+ and
assign that address to a Fortran integer*8 memory space (using \verb+long int *+ call-by-value).

So, on the above platforms, Fortran can carry addresses in \verb+integer*8+
variables.  These addresses might not have originated in any Fortran call,
and if they are addresses to inhomogeneously typed collections of data
(e.g. C structures), Fortran might not have enough information to dereference
the addresses.  But Fortran can still carry around such addresses, and in
particular hand them back and forth between various C functions.  The
{\slshape hypre} Fortran interface makes extensive use of this technique.

\vspace{0.1in}

\noindent Example:

\vspace{0.1in}

  Fortran calling:
\begin{verbatim}
      integer*8        addr
      integer          intg, ierr
      character        charact
      double precision double_precis

      call subroutine_name(addr, intg, charact, double_precis, ierr)
\end{verbatim}

The interface is designed so that the label \verb+subroutine_name+ is exactly
the label of the {\slshape hypre} C-function.  The {\slshape} Hypre interlanguage interface
accounts for related compilation/linking issues involving appended
underscores.  Fortran variables like \verb+addr+
are convenient for receiving, from C, pointers to arrays or other
collections of data.  Such pointers need not point to data allocated by Fortran.
Fortran variable \verb+ierr+ exemplifies a convenient approach to error
handling through the interface.

The above implementation might not have the portability needed over a larger set
of platforms.  Reliance on the previous mapping might be a weakness.
Furthermore,
the implementation is hand-programmed, slow, and prone to human error.
It will probably be replaced by a more automated implementation in accordance
with the {\slshape Babel} project. 

%  C called:
%\begin{verbatim}
%      void hypre_F90_NAME(sub_name)( long int  *struct_addr,
%                                     int       *intg,
%                                     char      *charact,
%                                     double    *double_prec,
%                                     int       *ierr          )
%\end{verbatim}

%\section{Fortran subroutine calls in {\slshape hypre} source code}

%\vspace{0.1in}

%\noindent Example:

%\vspace{0.1in}

%  C calling:
%\begin{verbatim}
%      long int long_intg;
%      int      intg, ierr;
%      char     charact;
%      double   double_prec;

%      hypre_F90_NAME(sub_name)( &long_intg, &intg, &charact,
%                               &double_prec, &ierr )
%\end{verbatim}

%  Fortran called:
%\begin{verbatim}
%      subroutine sub_name(long_intg, intg, charact, double_prec, ierr)

%      integer*8        long_intg
%      integer          intg, ierr
%      character        charact
%      double precision double_prec
%\end{verbatim}

%==========================================================================
