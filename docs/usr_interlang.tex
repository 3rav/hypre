\chapter{Interoperability with Fortran}

%==========================================================================
\section{Calls to {\slshape hypre} from Fortran source code}

Fortran 77 subroutine arguments always pass copies of the argument addresses
upon execution of the subroutine call.
This is referred to as call-by-address or call-by-reference.
In the called subroutine, the memory space at the
argument address can be altered, but the calling address cannot be
altered.

C function parameters, whether pointers (addresses) or not, are
directly copied upon
entry to the function. This is referred to as call-by-value.
Altering the copied C parameter in the
called function has no effect on the parameter in the calling function. 
A pointer parameter in C can achieve the same effect as call-by-reference,
and by this mechanism the languages can interoperate in a straightforward
manner.

Portability across typical platforms\footnote{DEC Compass, DEC Tera, and IBM ASCI-Blue at LLNL}
is currently achieved with the specific Fortran-calling-C mapping: 

\vspace{0.2in}

\begin{tabular}{lcl}

\underline{calling Fortran argument type} & &
\underline{called C function parameter type} \\
                              &                   &   \\
\hspace{0.1in} (addr of) \verb+integer*8+        & $\longrightarrow$ &
\hspace{0.5in} \verb+long int*+ \\
\hspace{0.1in} (addr of) \verb+integer+          & $\longrightarrow$ &
\hspace{0.5in} \verb+int*+ \\
\hspace{0.1in} (addr of) \verb+character+        & $\longrightarrow$ &
\hspace{0.5in} \verb+char*+ \\
\hspace{0.1in} (addr of) \verb+double precision+ & $\longrightarrow$ &
\hspace{0.5in} \verb+double*+ \\

\end{tabular}

\vspace{0.2in}

In particular, C-type
\verb+long int*+ points to a space that can hold an address, a space
which happens to be the size of that allocated by a Fortran
\verb+integer*8+ declaration.
In orther words, C can hold an address to anything in a \verb+long int+ and
assign that address to a Fortran \verb+integer*8+ memory space
(using \verb+long int*+ call-by-value).

Addresses in \verb+integer*8+ variables might not have originated
in a Fortran call, and if they address inhomogeneously typed collections
of data (e.g. C structures), Fortran might not have enough information to
dereference them.  But Fortran can still pass around such addresses, and in
particular hand them back and forth between various C functions.  The
{\slshape hypre} Fortran interface makes extensive use of this technique.

\vspace{0.1in}

\noindent Generalized example:

\vspace{0.1in}

  Fortran calling:
\begin{verbatim}
      integer*8        addr
      integer          intg, ierr
      character        charact
      double precision double_precis

      call subroutine_name(addr, intg, charact, double_precis, ierr)
\end{verbatim}

The interface is designed so that the label \verb+subroutine_name+ is exactly
the label of the {\slshape hypre} C-function.
{\slshape Hypre} interlanguage C-wrappers currently
account for related compilation/linking issues involving appended
underscores, and for Fortran name length limitations\footnote{For C
function names under 32 characters in length, the Fortran name is the same
as the C name.  For C function names over 31 characters, the Fortran
name is condensed to less than 32 characters (see reference manual for
Fortran name).}.
Fortran variables like \verb+addr+
are convenient for receiving, from C, pointers to arrays or other
collections of data.  Such pointers need not point to data allocated by
Fortran.  Fortran variable \verb+ierr+ exemplifies a convenient approach
to error handling through the interface.

\vspace{0.1in}

\noindent Specific example:

\vspace{0.1in}

  Fortran calling:
\begin{verbatim}
      integer*8        IJmatrix, 
      integer          num_nonzero_coefs, row_index
      integer          col_indices(MAX_NUM_COLS), ierr
      double precision coefs(MAX_NUM_COLS)
             .
             .
             .

      call HYPRE_IJMatrixInsertRow(IJmatrix, num_nonzero_coefs, row_index,
                                   col_indexes, coefs, ierr)
\end{verbatim}

\vspace{0.1in}

  C called:
\begin{verbatim}
      int HYPRE_IJMatrixInsertRow( HYPRE_IJMatrix IJmatrix, int n,
                                   int row, const int *cols,
                                   const double *values)     

      { int ierr = 0;
              .
              .
              .

        return(ierr); }
\end{verbatim}

\noindent Since the C function name has less than 32 characters, Fortran uses the
same name in the subroutine call.

The typical implementation above might not have the portability needed
over a larger set of platforms.  The previous mapping might
not be universal.  Furthermore,
the implementation is hand-programmed, slow, and prone to human error.
It will probably be replaced by a more automated implementation in accordance
with the {\slshape Babel} project. 

%  C called:
%\begin{verbatim}
%      void hypre_F90_NAME(sub_name)( long int *struct_addr,
%                                     int      *intg,
%                                     char     *charact,
%                                     double   *double_prec,
%                                     int      *ierr          )
%\end{verbatim}

%\section{Fortran subroutine calls in {\slshape hypre} source code}

%\vspace{0.1in}

%\noindent Example:

%\vspace{0.1in}

%  C calling:
%\begin{verbatim}
%      long int long_intg;
%      int      intg, ierr;
%      char     charact;
%      double   double_prec;

%      hypre_F90_NAME(sub_name)( &long_intg, &intg, &charact,
%                               &double_prec, &ierr )
%\end{verbatim}

%  Fortran called:
%\begin{verbatim}
%      subroutine sub_name(long_intg, intg, charact, double_prec, ierr)

%      integer*8        long_intg
%      integer          intg, ierr
%      character        charact
%      double precision double_prec
%\end{verbatim}

%==========================================================================
