\chapter{Interoperability with Fortran}

%==========================================================================
\section{Calls to {\slshape hypre} from Fortran source code}

Fortran 77 subroutine arguments always pass copies of the argument addresses
upon execution of the subroutine call.
This is referred to as call-by-address or call-by-reference.
In the called subroutine, the memory space at the
argument address can be altered, but the calling address cannot be
altered.

C function parameters, whether pointers (addresses) or not, are
directly copied upon
entry to the function. This is referred to as call-by-value.
Altering the copied C parameter in the
called function has no effect on the parameter in the calling function. 
A pointer parameter in C can achieve the same effect as call-by-reference,
and by this mechanism the languages can interoperate in a straightforward
manner.

Portability across typical platforms\footnote{Including DEC Compass, DEC Tera, and IBM ASCI-Blue at LLNL.}
is currently achieved with the specific Fortran-calling-C mapping: 

\vspace{0.2in}

\begin{tabular}{lcl}

\underline{calling Fortran argument type} & &
\underline{called C function parameter type} \\
                              &                   &   \\
\hspace{0.1in} (addr of) \verb+integer*8+        & $\longrightarrow$ &
\hspace{0.5in} \verb+long int*+ \\
\hspace{0.1in} (addr of) \verb+integer+          & $\longrightarrow$ &
\hspace{0.5in} \verb+int*+ \\
\hspace{0.1in} (addr of) \verb+character+        & $\longrightarrow$ &
\hspace{0.5in} \verb+char*+ \\
\hspace{0.1in} (addr of) \verb+double precision+ & $\longrightarrow$ &
\hspace{0.5in} \verb+double*+ \\

\end{tabular}

\vspace{0.2in}

In particular, C-type
\verb+long int*+ points to a space that can hold an address, a space
which happens to be the size of that allocated by a Fortran
\verb+integer*8+ declaration.
In orther words, C can hold an address to anything in a \verb+long int+ and
assign that address to a Fortran \verb+integer*8+ memory space
(using \verb+long int*+ call-by-value).

Addresses in \verb+integer*8+ variables might not have originated
in a Fortran call, and if they address inhomogeneously typed collections
of data (e.g. C structures), Fortran might not have enough information to
dereference them.  But Fortran can still pass around such addresses, and in
particular hand them back and forth between various C functions.  The
{\slshape hypre} Fortran interface makes extensive use of this technique,
as with the \verb+addr+ variable in the following general example:

\vspace{0.1in}

\noindent Generalized example:

\vspace{0.1in}

  Fortran calling:
\begin{verbatim}
      integer*8        addr
      integer          intg, ierr
      character        charact
      double precision double_precis

      call subroutine_name(addr, intg, charact, double_precis, ierr)
\end{verbatim}

The interface is designed so that the label \verb+subroutine_name+ is exactly
the label of the {\slshape hypre} C-function\footnote{For C
function names under 32 characters in length, the Fortran name is the same
as the C name.  For C function names over 31 characters, the Fortran
name is condensed to less than 32 characters (see reference manual for
Fortran name in such a case).}.
{\slshape Hypre} interlanguage C-wrappers currently
account for interlanguage linking issues involving appended
underscores.  The C-wrappers also accomodate Fortran subroutine name length
limitations.  Fortran variable \verb+ierr+ allows error handling through
the interface.

\vspace{0.1in}

\noindent Specific example:

\vspace{0.1in}

  Fortran calling:
\begin{verbatim}
      integer*8        IJmatrix, 
      integer          num_nonzero_coefs, row_index
      integer          col_indices(MAX_NUM_COLS), ierr
      double precision coefs(MAX_NUM_COLS)
             .
             .
             .

      call HYPRE_IJMatrixInsertRow(IJmatrix, num_nonzero_coefs, row_index,
                                   col_indices, coefs, ierr)
\end{verbatim}

\vspace{0.1in}

  C called:
\begin{verbatim}
      int HYPRE_IJMatrixInsertRow( HYPRE_IJMatrix IJmatrix, int n,
                                   int row, const int *cols,
                                   const double *values)     

      { int ierr = 0;
              .
              .
              .

        return(ierr); }
\end{verbatim}

\noindent Since the C function name has less than 32 characters, Fortran
uses the same name in the subroutine call.

The typical implementation above might not have the portability needed
over a larger set of platforms.  The previous mapping might
not be universal.  Furthermore,
the implementation is hand-programmed, slow, and prone to human error.
It will probably be replaced by a more automated implementation in accordance
with the {\slshape Babel} project. 

%==========================================================================
