%==========================================================================
\section{BoomerAMG}

BoomerAMG is a parallel implementation of algebraic multigrid.
It can be used both as a solver or as a preconditioner.
The user can choose between various different parallel coarsening techniques
and relaxation schemes.
The following coarsening techniques are available:
\begin{itemize}
\item the Cleary-Luby-Jones-Plassman (CLJP) coarsening,
\item various variants of the classical Ruge-Stueben (RS) coarsening algorithm, and
\item the Falgout coarsening which is a combination of CLJP and the
classical RS coarsening algorithm.
\end{itemize}
The following relaxation techniques are available:
\begin{itemize}
\item weighted Jacobi relaxation,
\item a hybrid Gauss-Seidel / Jacobi relaxation scheme, and
\item sequential Gauss-Seidel relaxation.
\end{itemize}

\subsection{Synopsis}

The solver is set up and run using the following routines,
where A is the matrix, b the right hand side and x the solution vector
of the linear system to be solved:

\begin{display}
\begin{verbatim}
#include "HYPRE_parcsr_ls.h"

int HYPRE_BoomerAMGCreate(HYPRE_Solver *solver); 

<set certain parameters if desired >

int HYPRE_BoomerAMGSetup(HYPRE_Solver solver, HYPRE_ParCSRMatrix A,
  HYPRE_ParVector b, HYPRE_ParVector x);
int HYPRE_BoomerAMGSolve(HYPRE_Solver solver, HYPRE_ParCSRMatrix A,
  HYPRE_ParVector b, HYPRE_ParVector x);
int HYPRE_BoomerAMGDestroy(HYPRE_Solver solver);
\end{verbatim}
\end{display}

\subsection{Interface functions}

Parameters for setting up the code are specified using the following routines:

\subsubsection*{HYPRE\_BoomerAMGSetMaxLevels}
\begin{display}
\begin{verbatim}
int HYPRE_BoomerAMGSetMaxLevels( HYPRE_Solver solver, int max_levels);
\end{verbatim}
\end{display}
max\_levels defines the maximal number of multigrid levels allowed.
The default is 25.

\subsubsection*{HYPRE\_BoomerAMGSetMaxIter}
\begin{display}
\begin{verbatim}
int HYPRE_BoomerAMGSetMaxIter( HYPRE_Solver solver, int max_iter);
\end{verbatim}
\end{display}
max\_iter defines the maximal number of iterations allowed.
The default is 20.

\subsubsection*{HYPRE\_BoomerAMGSetTol}
\begin{display}
\begin{verbatim}
int HYPRE_BoomerAMGSetTol( HYPRE_Solver solver, double tol);
\end{verbatim}
\end{display}
tol defines the tolerance needed for the stopping criterion
$\| b ~ - ~ Ax^{(n)} \|_2 / \| b \|_2 \leq $ tol.
The default for tol is $10 ^{-7}$.

\subsubsection*{HYPRE\_BoomerAMGSetStrongThreshold}
\begin{display}
\begin{verbatim}
int HYPRE_BoomerAMGSetStrongThreshold( HYPRE_Solver solver,
	double strong_threshold);
\end{verbatim}
\end{display}
A point $i$ is strongly connected to $j$, if $-a_{i,j} \geq \theta 
\max_{j \neq i} \-a_{ij}$, where the strong threshold $\theta$ is a value
between 0 and 1. Weak connections are usually ignored when determining
the next lower level. Consequently, choosing a larger strong threshold
leads in general to smaller coarse grids, but worse convergence rates.
The default value for $\theta$
is 0.25, which appears to be a good choice for 2-dimensional
problems. A better choice for 3-dimensional problems appears to be 0.5. However,
the choice of the strength threshold is problem dependent and therefore
there could be better choices than the two suggested ones.

\subsubsection*{HYPRE\_BoomerAMGSetMaxRowSum}
\begin{display}
\begin{verbatim}
int HYPRE_BoomerAMGSetMaxRowSum( HYPRE_Solver solver, double max_row_sum);
\end{verbatim}
\end{display}
This feature leads to a more efficient treatment of very
diagonally dominant portions of the matrix.
If the absolute row sum of row i weighted by the diagonal
is greater than max\_row\_sum all dependencies of variable i are set
to be weak. 
This feature can be switched off by setting max\_row\_sum to 1.0.
The default is 0.9.

\subsubsection*{HYPRE\_BoomerAMGSetCoarsenType}
\begin{display}
\begin{verbatim}
int HYPRE_BoomerAMGSetCoarsenType( HYPRE_Solver solver, int coarsen_type  );
\end{verbatim}
\end{display}
coarsen\_type defines the coarsening used. The following options 
are possible:

\begin{tabular}{l l}
  0 & CLJP-coarsening \\
  1& 	Ruge-Stueben coarsening without boundary treatment \\
  3& 	Ruge-Stueben coarsening with a 3rd 'second' pass on the boundaries \\
 6 & 	Falgout coarsening (default) \\
\end{tabular}

\subsubsection*{HYPRE\_BoomerAMGSetMeasureType}
\begin{display}
\begin{verbatim}
int HYPRE_BoomerAMGSetMeasureType( HYPRE_Solver solver, int measure_type  );
\end{verbatim}
\end{display}
measure\_type defines 
whether local (measure\_type = 0, default) or global measures 
(measure\_type = 1) are used within the coarsening 
algorithm. This feature is ignored for the CLJP and the Falgout coarsening.

\subsubsection*{HYPRE\_BoomerAMGSetNumGridSweeps}
\begin{display}
\begin{verbatim}
int HYPRE_BoomerAMGSetNumGridSweeps( HYPRE_Solver solver, int* num_grid_sweeps );
\end{verbatim}
\end{display}
num\_grid\_sweeps[k] defines the number of sweeps over the grid on the fine 
grid (k=0), the down cycle (k=1), the up cycle (k=2) and the coarse grid (k=3).

\subsubsection*{HYPRE\_BoomerAMGSetGridRelaxType}
\begin{display}
\begin{verbatim}
int HYPRE_BoomerAMGSetGridRelaxType( HYPRE_Solver solver, int* grid_relax_type );
\end{verbatim}
\end{display}
grid\_relax\_type[k] defines the relaxation used on the fine 
grid (k=0), the down cycle (k=1), the up cycle (k=2) and the coarse grid (k=3).
The following options are possible for grid\_relax\_type[k]:

\begin{tabular}{l l}
 0 & weighted Jacobi \\
 3 & Gauss-Seidel / Jacobi hybrid method (default) \\
 9 & Gaussian elimination (only for the coarsest level (k=3), not recommended\\ 
 & if the system on the coarsest level is large)\\
\end{tabular}

\subsubsection*{HYPRE\_BoomerAMGSetGridRelaxPoints}
\begin{display}
\begin{verbatim}
int HYPRE_BoomerAMGSetGridRelaxPoints( HYPRE_Solver solver, 
	int** grid_relax_points);
\end{verbatim}
\end{display}
grid\_relax\_points[k][l] defines which points are to be relaxed during
the (l+1)-th sweep on the fine 
grid (k=0), the down cycle (k=1), the up cycle (k=2) and the coarse grid (k=3),
e.g. if grid\_relax\_points[1][0] is -1, all points marked -1 (which are in
general fine points) are relaxed on the first sweep of the down cycle.
Note: grid\_relax\_points[3][l] needs to be 0 always, since the concept of 
coarse and fine points does not exist on the coarsest grid. If the user
sets it to another value, it will be automatically set to 0 and a warning
printed, unless the direct solver is used.

\subsubsection*{HYPRE\_BoomerAMGSetRelaxWeight}
\begin{display}
\begin{verbatim}
int HYPRE_BoomerAMGSetRelaxWeight( HYPRE_Solver solver, double* relax_weight);
\end{verbatim}
\end{display}
defines the relaxation weights used on each level, if weighted Jacobi is used
as relaxation method. The default relaxation weight is 1.0 on each level.

\subsubsection*{HYPRE\_BoomerAMGSetIOutDat}
\begin{display}
\begin{verbatim}
int HYPRE_BoomerAMGSetIOutDat( HYPRE_Solver solver, int ioutdat);
\end{verbatim}
\end{display}
where ioutdat determines whether statistics information is generated and 
printed. The information is printed to standard output.
The following options are possible:

\begin{tabular}{l l}
 0 & no output (default) \\
 1 & matrix statistics (includes information on interpolation operators and \\
 & matrices generated on each level) \\
 2 & cycle statistics (includes residuals generated during solve phase) \\
 3 & matrix and cycle statistics \\
\end{tabular}

%==========================================================================
