%=============================================================================
%=============================================================================

\chapter{Babel-based Interfaces}
\label{ch-babel}

\section{Introduction}

Much of \hypre{} is accessible through a multi-language interface
built through the Babel tool.  This tool can connect to \hypre{} from
your code which you can write in any of several languages.

The Struct (Structured grid), SStruct (Semi-Structured grid), and IJ
(linear algebra style) interfaces all can be used
this way.  The code you write to call \hypre{} functions through the
Babel-based interface works much the same as the code you write to
call them through the original C interface.  The function names are
different, the object structure of \hypre{} is more visible, and there
are many more minor differences.

This chapter will discuss these differences and present brief
examples.  You can also see them in action by looking at the complete
examples in the examples directory.

You do not need to have the Babel software to use the Babel-based
interface of \hypre{}.  Prebuilt interfaces for the C, C++, and
Fortran languages are included with the \hypre{} distribution.  A
prebuilt Python interface will appear in the near future.  We will
enlarge the distribution with more such interfaces whenever \hypre{}
users indicate that they need them, and our tools such as Babel
support them.  Although you do not need to know about Babel to use the
Babel-based interface of \hypre{}, if you are curious about Babel you
can look at its documentation at
\url{http://www.llnl.gov/CASC/components}.

\section{Interfaces are Similar}
\label{sec-Interfaces-Similar}

In most respects, the older C-only interface and the Babel-based
interface are very similar. The function names always differ a little,
and often there are minor differences in the argument lists.  The
following sections will discuss the more significant differences, but
this example shows how similar the interfaces can be.  The first
example is for the C-only interface, and the other examples are for
the Babel interface in the C, C++, Fortran, and Python languages.

\begin{verbatim}
   HYPRE_IJVectorInitialize( b );
   bHYPRE_IJParCSRVector_Initialize( b, &_ex );
   b.Initialize();
   call bHYPRE_IJParCSRVector_Initialize_f( b, ierr, ex )
   bHYPRE.IJParCSRVector.Initialize( b )
\end{verbatim}


\section{Interfaces are Different}
\label{sec-Interfaces-Different}

Function names usually differ in minor ways, as decribed in the
following section \ref{sec-Names-Conventions}.  But sometimes they
differ more; for example to apply a solver to solve linear equations,
you say \code{Solve} in the C-only interface and \code{Apply} in the
Babel-based interface.  For information on particular functions, see
the reference manuals or example files.

Function argument lists look mainly the same.  The data types of many
arguments are different as required, for example in C a preconditioner
would be a \code{HYPRE_Solver} in the C-only interface, or a
\code{bHYPRE_Solver} in the Babel-based interface.  Sometimes there
are greater differences; the greatest ones are discussed below.
Again, see the reference manuals or example files for more specific
information.

In C or Fortran, the Babel-based interface requires an extra argument
at the end, called the ``exception.''  It is not necessary for C++ or
Python.  You should ignore it, but it has to be there.  In C you
should declare it as follows.
\begin{verbatim}
  #include "sidl_Exception.h"
  sidl_BaseInterface_ex;
\end{verbatim}
And in Fortran you should declare it as follows.
\begin{verbatim}
      integer*8  ex
\end{verbatim}

Parameters are set differently in the C-only and Babel-based
interfaces.  In the C interface there is a different \code{Set}
function for each parameter; the parameter name is part of the
function name.  In the Babel-based interface there are just a few
\code{Set*Parameter} interfaces.  The parameter is one of the
arguments.  For details see section
\ref{sec-Parameters-ErrorFlags}, or look in an example file.

MPI communicators are passed differently, in the native form in the
C-only interface and as a language-neutral object in the Babel-based
interface.  For details see section \ref{sec-MPI}.

In two rare cases, the Babel-based interface of \hypre{} provides
output arrays in a special format.  See section \ref{sec-Arrays}
if you need to deal with it.

With the Babel-based interface in the C or Fortran languages, you will
occasionally need to explicitly cast an object between different data
types.  You do this with a special \code{cast} function.  Moreover,
for every time you create or cast an object you need a corresponding
call of a \code{Destroy} or \code{deleteRef} function. See the
sections \ref{sec-Memory} and \ref{sec-Casting} for details.


\section{Names and Conventions}
\label{sec-Names-Conventions}

In the C-only interface, most \hypre{} function names look like
\code{HYPRE_ClassFunction} where \code{Class} is a class name and
\code{Function} is a (conceptual) function name.  The C-Babel
interface is similar: most function names look like
\code{bHYPRE_Class_Function}.  In the Fortran-Babel interface, most
function names look like \code{bHYPRE_Class_Function_f}.  In the
C++-Babel interface, SIDL (Babel) classes are actually implemented as
classes, so functions generally look like Instance.Function, where
Instance is an instance of the class.  In C++, the
Babel-interface functions live in the namespace \code{::ucxx::bHYPRE}.

This function naming pattern is slightly broken in the case of service
functions provided by Babel rather than \hypre{}.  All of them contain
a double underscore, \code{__}.  These functions are used for casting,
certain arrays, and sometimes memory management.  For more information
see sections \ref{sec-ObjectStructure}, \ref{sec-Arrays}, and
\ref{sec-Memory}.

Most functions are member functions of a class.  In
non-object-oriented languages, the first argument of the function will
be the object which ``owns'' the function.  For example, to solve
equations with a PCG solver you ``apply'' it to vectors using its
member function \code{Apply}.  In C++, C, and Fortran this concept is
expressed as:
\begin{verbatim}
      pcg_solver.Apply( b, x );   (C++;in the ::ucxx::bHYPRE namespace)
      bHYPRE_PCG_Apply( PCG_solver, b, &x, ex );   (C)
      call bHYPRE_PCG_Apply_f( PCG_solver, b, x, ierr, ex )   (Fortran)
\end{verbatim}

In the Babel interface, data types usually look like \code{Class} in
C, \code{bHYPRE_Class} in C, and \code{integer*8} in Fortran.  Similar
data types in the C-only interface would look like
\code{HYPRE_Class}.  Here \code{Class} is a class name where the
interface is defined in the SIDL file \code{Interfaces.idl}.
Sometimes the class name is slightly different in the C-only
interface, but usually they are the same.

Most \hypre{} objects need to be supplied with an MPI communicator.
The Babel interface has a special class for the MPI communicator; for
details see section \ref{sec-MPI}.

\section{Parameters and Error Flags}
\label{sec-Parameters-ErrorFlags}

Most \hypre{} objects can be modified by setting parameters.  In the
C-only interface, there is a separate function to set each parameter.
The Babel-based interface has just a few parameter-setting functions
for each object.  The parameters are identified by their names, as
strings.  See below for some examples.

Most \hypre{} functions return error flags, as discussed elsewhere in
this manual. The following examples simply show how they are returned,
not how to handle them.

\subsubsection{C-only}
\begin{verbatim}
    HYPRE_Solver amg_solver;
    int ierr;
    ierr = HYPRE_BoomerAMGSetCoarsenType( amg_solver, 6 );
    ierr = HYPRE_BoomerAMGSetTol( amg_solver, 1e-7 );
\end{verbatim}

\subsubsection{C-Babel}
\begin{verbatim}
    bHYPRE_BoomerAMG amg_solver;
    int ierr;
    ierr = bHYPRE_BoomerAMG_SetIntParameter( amg_solver, "CoarsenType", 6, ex );
    ierr = bHYPRE_BoomerAMG_SetDoubleParameter( amg_solver,
                                                "Tolerance", 1e-7, ex);
\end{verbatim}

\subsubsection{Fortran-Babel}
\begin{verbatim}
          integer*8  amg_solver
          integer ierr
          call bHYPRE_BoomerAMG_SetIntParameter_f(
         1        amg_solver, "CoarsenType", 6, ierr, ex )
          call bHYPRE_BoomerAMG_SetDoubleParameter_f(
         1        amg_solver, "Tolerance", tol, ierr, ex )
\end{verbatim}

\subsubsection{C++-Babel}
\begin{verbatim}
    using namespace ::ucxx::bHYPRE;
    BoomerAMG amg_solver;
    ierr = amg_solver.SetIntParameter( "CoarsenType", 6);
    ierr = amg_solver.SetDoubleParameter( "Tolerance", 1e-7);
\end{verbatim}

\section{MPI communicator}
\label{sec-MPI}

In the C-only \hypre{} interface, and most normal MPI usage, one often
needs an MPI communicator of type \code{MPI_Comm}.  What an
\code{MPI_Comm} really is depends on the language and the MPI
implementation.

But the Babel interface is supposed to be fundamentally independent of
languages and implementations.  So the MPI communicator is wrapped in
a special \code{bHYPRE_MPICommunicator} object.  This, not an
\code{MPI_Comm} object, is what you pass to all the Babel-interface
functions which need an MPI communicator.  Thus the language
dependence of MPI is isolated in the function which creates the
\code{bHYPRE_MPICommunicator} object.  Here are examples of how to use
this function:

\subsubsection{C-Babel}
\begin{verbatim}
    bHYPRE_MPICommunicator mpi_comm;
    MPI_Comm mpicommworld = MPI_COMM_WORLD;
    MPI_Comm * C_mpi_comm = &mpicommworld;
    mpi_comm = bHYPRE_MPICommunicator_CreateC( C_mpi_comm, ex );
       ...
    parcsr_A = bHYPRE_IJParCSRMatrix_Create( mpi_comm,... );
\end{verbatim}

\subsubsection{C++-Babel}
\begin{verbatim}
    using namespace ::ucxx::bHYPRE;
    MPICommunicator mpi_comm;
    MPI_Comm mpicommworld = MPI_COMM_WORLD;
    MPI_Comm * C_mpi_comm = &mpicommworld;
    mpi_comm = MPICommunicator::CreateC( C_mpi_comm );
       ...
    parcsr_A = IJParCSRMatrix::Create( mpi_comm,... );
\end{verbatim}

\subsubsection{Fortran-Babel}
\begin{verbatim}
          integer*8  mpi_comm
          integer*8  F_mpi_comm
          F_mpi_comm = MPI_COMM_WORLD
          call bHYPRE_MPICommunicator_CreateF_f(F_mpi_comm,mpi_comm,ex)
             ...
          call bHYPRE_IJParCSRMatrix_Create_f( mpi_comm, ... )
\end{verbatim}

\section{Memory Management}
\label{sec-Memory}

You will want to destroy whatever objects you create.  In C and
Fortran, you must do this explicitly.  Through the Babel-based
interface to \hypre{}, there are two ways to create something: by
calling a \code{Create} function or by calling a
\code{cast} function. You can destroy things with a \code{Destroy}
or \code{deleteRef} function.  For every call of \code{Create} or
\code{cast} there must be a call of \code{Destroy} or
\code{deleteRef}.  Here is an example in C:
\begin{verbatim}
    b = bHYPRE_IJParCSRVector_Create( mpi_comm, ilower, iupper, ex );
    vb = bHYPRE_Vector__cast( b, ex );
    bHYPRE_Vector_deleteRef( vb, ex );
    bHYPRE_IJParCSRVector_deleteRef( b, ex );
\end{verbatim}
Here it is in Fortran:
\begin{verbatim}
      call bHYPRE_IJParCSRVector_Create_f( mpi_comm, ilower, iupper,
     1                                     b, ex )
      call bHYPRE_Vector__cast_f( b, vb, ex )
      call bHYPRE_IJParCSRVector_deleteRef_f( vb, ex )
      call bHYPRE_IJParCSRVector_deleteRef_f( b, ex )
\end{verbatim}

What is actually going on here is memory management by reference
counting.  Babel references-counts all its objects.  Reference
counting means that the object contains an integer which counts the
number of outside references to the object.  Babel will bump up the
reference count by one when you call a \code{Create} or \code{cast}
function.  Note that each of those functions normally is used to
assign an object to a variable.  In C and Fortran it is up to you do
decrement the reference count when that variable is no longer needed.

With Babel, reference counting is automatic in C++, so you will not
normally need to do any memory management yourself.

If you are interested in doing more with reference counting, see the
Babel users' manual for more information.  In some cases you may find
Babel's memory tools useful, e.g. if you copy pointers to Babel
objects.


\section{Casting}
\label{sec-Casting}

If your code is written in C or Fortran, you will occasionally need to
call a Babel \code{cast} function.  This section tells you why and
how.

Functions are generally written in as much generality as possible.
For example, the PCG algorithm works the same for any kind of matrix
and vector, as long as it can multiply a matrix and vector, compute an
inner product, and so forth.  So two of its argument types are
\code{bHYPRE_Vector}.  But when you create a vector you have to decide
how it's going to be stored!  So you have to declare it as a more
specific data type, e.g. \code{bHYPRE_StructVector}.  To apply the PCG
solver to that vector in C or Fortran, you have to call a \code{cast}
function to change its data type.

In C++ and Python, you do not normally need to call a \code{cast}
function.

Be careful to call a \code{deleteRef} or \code{Destroy} function to
correspond to every \code{cast} function, as discussed in section
\ref{sec-Memory}.

Here are examples of casting in C and Fortran.
\begin{verbatim}
    bHYPRE_StructVector b_S = bHYPRE_StructVector_Create(...);
    bHYPRE_Vector       b = bHYPRE_Vector__cast( b_S, ex );
    hypre_Vector        x;
    bHYPRE_PCG          PCG_solver;
    bHYPRE_PCG_Apply( PCG_solver, b, &x, ex );
    bHYPRE_Vector_deleteRef( b, ex );
    bHYPRE_StructVector_deleteRef( b_S, ex );
\end{verbatim}
\begin{verbatim}
      integer*8 b_S
      integer*8 b
      integer*8 x
      integer*8 PCG_solver
      call bHYPRE_StructVector_Create_f(...,b_S, ex )
      call bHYPRE_Vector__cast_f( b_S, b, ex )
      call bHYPRE_PCG_Apply_f( PCG_solver, b, x, ierr, ex )
      call bHYPRE_Vector_deleteRef_f( b, ex )
      call bHYPRE_StructVector_deleteRef_f( b_S, ex )
\end{verbatim}
(Other code not shown would set up the matrix, provide it and
parameters to the solver, set up the vectors, and so forth).

\section{The HYPRE Object Structure}
\label{sec-ObjectStructure}

Even though it is written in C, \hypre{} is object-oriented in its
conceptual design.  The object structure of \hypre{} is often visible,
for example in names of structs and functions.  It is even more
visible in the Babel-based interface than in the C-only interface.  In
both interfaces, you can use \hypre{} without any knowledge of its
object structure or object-oriented programming.  This section is for
you if you have some basic knowledge of object-oriented concepts and
if you are curious about how they appear in \hypre{}.

The object structure of the Babel-based interface is explicitly
defined in the SIDL (Scientific Interface Definition Language) file
\code{Interfaces.idl}.  Babel translates this object structure as
appropriate for the language the user uses - from SIDL's interfaces
and classes to C++ classes, or to mangled names in C and Fortran.
For more information about the SIDL language, visit the Babel project
website, \url{http://www.llnl.gov/CASC/components}.

Here is an example: In the SIDL file defining the Babel interface, the
StructVector class inherits from the StructVectorView and Vector
interfaces.  StructVectorView extends MatrixVectorView interface,
which extends the ProblemDefinition interface.  The Babel StructVector
class can appear as a C++ class also named \code{StructVector} (in the
\code{bHYPRE} namespace), as a C struct named
\code{bHYPRE_StructVector}, or as a Fortran
\code{integer*8}.  Its member function SetValues can appear in C++ as a
member function \code{SetValues}, in C as a function
\code{bHYPRE_StructVector_SetValues}, or in Fortran as a subroutine
\code{bHYPRE_StructVector_SetValues}.

The inheritance structure matters in use because sometimes you must
cast an object up and down its inheritance hierarchy to provide an
object of the right data type in a function call.  See section
\ref{sec-Casting}.

Figure~\ref{figObjectModel} describes in abbreviated form the most
important ideas of the \hypre{} inheritance hierarchy.


\begin{figure}
\centering
\includegraphics[width=5in]{figObjectModel}
\caption{%
The ideas of the hypre object model.}
\label{figObjectModel}
\end{figure}

% The same chart appears in the following two places, among others.
% 1. page 5 of ``The Design and Implementation of hypre, a Library of
% Parallel High Performance Preconditioners''
% (jfp has this in an email from Rob Falgout on May 13, 2005)
% 2. slide 79 of ACTS viewgraphs on hypre dated August 23, 2005 (jfp
% has this in an email from Rob Falgout dated July 19, 2006)


% >>>>>>> a more complete chart would be nice, if it would fit! <<<<<<<<

% >>>>>>> a verbal description of the object system, e.g. what is a
% view, is ESSENTIAL ! <<<<<<<<<
% concepts to include:
% conceptual interface (e.g. IJ) vs 'underlying storage type' (e.g. ParCSR)

\section{Arrays}
\label{sec-Arrays}

Almost always, when you pass an array through the Babel-based
interface, you do it in the natural way - you build and use the array
type which is native to your language.  Babel calls this kind or array
a ``raw array'' or ``rarray.''  In \hypre{}, they are
one-dimensional too.  It is usually obvious how to use them.

Just two functions in \hypre{}, \code{GetRow} and
\code{CoefficentAccess}, require a special type of array, which Babel
calls a ``SIDL array.''  This has more structure than the arrays
native to languages like C or Fortran - it accomodates reference
counting and knows its own size, for example.

The following examples show a way to declare, read, and destroy a SIDL
array.  The GetRow and CoefficentAccess functions create their output
arrays, so there is no need to create your own.  For more information
on these arrays, read the Babel documentation at
\url{http://www.llnl.gov/CASC/components}.

% I've never done any of this.  This should be put in the test
% programs sometime.

\subsubsection{C}
\begin{verbatim}
    struct sidl_int__array *row_js;
    struct sidl_double__array *row_data;
    bHYPRE_IJParCSRMatrix_GetRow( A, i, &row_size, &row_js, &row_data, ex );
    for ( k=0; k<row_size; ++k )
       col[k]  = sidl_int__array_get1( row_js, k );
       data[k] = sidl_double__array_get1( row_data, k );
    sidl_int__array_deleteRef( row_j, ex );
    sidl_double__array_deleteRef( row_data, ex );
\end{verbatim}
\subsubsection{Fortran}
\begin{verbatim}
      integer*8 row_js;
      integer*8 row_data;
      call bHYPRE_IJParCSRMatrix_GetRow_f( A, i, row_size, row_js,
     1                                     row_data, ex )
      do k = 1, row_size
         call sidl_int__array_get1_f( row_js, k-1, col(k) )
         call sidl_double__array_get1_f( row_data, k-1, data(k) )
      enddo
      call sidl_int__array_deleteRef( row_j, ex )
      call sidl_double__array_deleteRef( row_data, ex )
\end{verbatim}


\section{Matrices and Vectors}
\label{sec-Matrices-Vectors}

\subsection{ParCSR Matrices}
\label{subsec-ParCSRMatrices}

\subsubsection{C-Babel}
In C with the Babel-based interface, a ParCSR matrix is typically built as follows:

\begin{verbatim}
    bHYPRE_MPICommunicator mpi_comm;
    bHYPRE_IJParCSRMatrix parcsr_A;
    parcsr_A = bHYPRE_IJParCSRMatrix_Create(
      mpi_comm, row_lower, row_upper, col_lower, col_upper, ex );

    bHYPRE_IJParCSRMatrix_Initialize( parcsr_A, ex );

    /* SetValues sets values for matrix rows; normally there
       are many SetValues calls inside a loop ... */
    bHYPRE_IJParCSRMatrix_SetValues( parcsr_A, n_rows, n_cols, rows, cols,
                                     values, n_nonzeros, ex );

    bHYPRE_IJParCSRMatrix_Assemble( parcsr_A, ex );
\end{verbatim}

\subsubsection{C-only}
The same job in the C-only interface would be done as follows:

\begin{verbatim}
    MPI_COMM mpi_comm;
    HYPRE_IJMatrix A;
    HYPRE_IJMatrixCreate( mpi_comm, row_lower, row_upper, col_lower, col_upper, &A );

    HYPRE_IJMatrixSetObjectType( A, HYPRE_PARCSR );

    HYPRE_IJMatrixInitialize( A );

    /* SetValues sets values for matrix rows; normally there
       are many SetValues calls inside a loop ... */
    HYPRE_IJMatrixSetValues( A, n_rows, n_cols, rows, cols, values );

    HYPRE_IJMatrixAssemble(A);
\end{verbatim}


The most significant difference between the C-Babel and C-only
interfaces is that the C-only interface includes a SetObjectType
function call not found in the C-Babel interface.  This is because the
same information is incorporated in function names in the Babel
interface.  It is also notable that the MPI communicator is wrapped in
a special object in the Babel interface, but passed directly in the
C-only interface.  This is because the Babel interface is
language-neutral, but MPI communicator types are generally
language-dependent.  MPI communicators are discussed in section
\ref{sec-MPI}.

\subsubsection{C++-Babel}
Here is how the same matrix would be built in C++ and Fortran.
both with the same Babel-based interface as above.
You can see how everything works the same.  Most of this chapter
will not include non-C examples except in contexts where their differences
from C are interesting.

\begin{verbatim}
    using namespace ::ucxx::bHYPRE;
    MPICommunicator mpi_comm;
    IJParCSRMatrix parcsr_A;
    parcsr_A = IJParCSRMatrix::Create(
       mpi_comm, row_lower, row_upper, col_lower, colupper );

    parcsr_A.Initialize();

    // SetValues sets values for matrix rows; normally there
    //   are many SetValues calls inside a loop ...
    parcsr_A.SetValues( n_rows, n_cols, rows, cols, values, n_nonzeros );

    parcsr_A.Assemble();
\end{verbatim}


\subsubsection{Fortran-Babel}
\begin{verbatim}
          integer*8  bHYPRE_mpicomm
          integer*8  parcsr_A
          call bHYPRE_IJParCSRMatrix_Create_f(bHYPRE_mpicomm, row_lower,
         1     row_upper, col_lower, col_upper, parcsr_A, ex )

          call bHYPRE_IJParCSRMatrix_Initialize_f(parcsr_A,ierrtmp,ex )

    c        SetValues sets values for matrix rows; normally there
    c        are many SetValues calls inside a loop ...
             call bHYPRE_IJParCSRMatrix_SetValues_f(
         1        parcsr_A, n_rows, n_cols, rows, cols, values,
         2        n_nonzeros, ierrtmp, ex )

          call bHYPRE_IJParCSRMatrix_Assemble_f( parcsr_A, ierrtmp, ex )
\end{verbatim}



\subsection{Struct Matrices}

Struct matrices are built almost the same way with
the C-only and Babel+C interfaces.

\subsubsection{C-Babel}

In C, a Struct  matrix is typically built as follows with
the Babel interface:

\begin{verbatim}
    bHYPRE_MPICommunicator mpi_comm;
    bHYPRE_StructMatrix  A_b;
    bHYPRE_StructGrid grid;
    bHYPRE_StructStencil stencil;
    int *box_lower, *box_upper, *stencil_indices;
    double *values;

    A_b = bHYPRE_StructMatrix_Create( mpi_comm, grid, stencil, ex );
    ierr += bHYPRE_StructMatrix_Initialize( A_b, ex );

    /* SetBox values sets values for a block of the matrix;
       normally there are many SetBoxValues calls inside a loop.*/
    bHYPRE_StructMatrix_SetBoxValues(
                  A_b, box_lower, box_upper, dim,
                  stencil_size, stencil_indices, values, volume, ex );
    ierr += bHYPRE_StructMatrix_Assemble( A_b, ex );
\end{verbatim}


Other languages work the same way in the Babel interface; see
subsection \ref{subsec-ParCSRMatrices} for syntax examples.

\subsubsection{C-only}

This job is done as follows with the C-only interface:

\begin{verbatim}
    MPICommunicator mpi_comm;
    HYPRE_StructMatrix  A;
    HYPRE_StructGrid    grid;
    HYPRE_StructStencil stencil;
    int *box_lower, *box_upper, *stencil_indices;
    double *values;

    HYPRE_StructMatrixCreate( mpi_comm, grid, stencil, &A);
    HYPRE_StructMatrixInitialize(A);

    /* SetBox values sets values for a block of the matrix;
       normally there are many SetBoxValues calls inside a loop.*/
    HYPRE_StructMatrixSetBoxValues( A, box_lower, box_upper,
                                    stencil_size, stencil_indices, values);
    HYPRE_StructMatrixAssemble(A);
\end{verbatim}


Both interfaces work the same way, with minor differences in argument
lists and data types.

\subsection{SStruct Matrices}

SStruct matrices are built almost the same way with
the C-only and C-Babel interfaces.

\subsubsection{C-Babel}

In C, a SStruct  matrix is typically built as follows with
the Babel interface.  There are minor differences depending on the
kind of SStruct matrix, \code{object_type} in the following.  Its possible
values are \code{HYPRE_PARCSR}, \code{HYPRE_STRUCT}, \code{HYPRE_SSTRUCT}.

For \code{object_type==HYPRE_PARCSR}:
\begin{verbatim}
    bHYPRE_MPICommunicator mpi_comm;
    bHYPRE_SStructParCSRMatrix   A_b;
    bHYPRE_SStructGraph   graph;
    int object_type, dim, var, nentries, nvalues, part;
    int box_lower[3], box_upper[3], index[3];
    int *entries;

    A_b = bHYPRE_SStructParCSRMatrix_Create( mpi_comm, graph, ex );

    /* No call of SetObjectType is needed, the information is in
       the name of this Initialize function: */
    bHYPRE_SStructParCSRMatrix_Initialize( A_b, ex );

    /* SetBoxValues and SetValues are normally called inside loops */
    bHYPRE_SStructParCSRMatrix_SetBoxValues
          ( A_b, part, box_lower, box_upper, dim, var,
            nentries, entries, values, nvalues, ex );
           }
    bHYPRE_SStructParCSRMatrix_SetValues
          ( A_b, part, index, dim, var, nentries, entries, values, ex );

    bHYPRE_SStructParCSRMatrix_Assemble( A_b, ex );
\end{verbatim}


For \code{object_type==HYPRE_STRUCT} or \code{HYPRE_SSTRUCT}:
\begin{verbatim}
    bHYPRE_MPICommunicator mpi_comm;
    bHYPRE_SStructMatrix  A_b;
    bHYPRE_SStructGraph   graph;
    int object_type, n_dim, var, nentries, nvalues;
    int box_lower[3], box_upper[3], index[3];
    int *entries;

    A_b = bHYPRE_SStructMatrix_Create( mpi_comm, graph, ex );

    bHYPRE_SStructMatrix_SetObjectType(A_b, object_type, ex);
    bHYPRE_SStructMatrix_Initialize( A_b, ex );

    /* SetBoxValues and SetValues are normally called inside loops */
     bHYPRE_SStructMatrix_SetBoxValues
           ( A_b, part, boxlower, box_upper, dim, var,
             nentries, entries, values, nvalues, ex );
     bHYPRE_SStructMatrix_SetValues
           ( A_b, part, index, dim, var, nentries, entries, values, ex );

     bHYPRE_SStructMatrix_Assemble( A_b, ex );
\end{verbatim}

\subsubsection{C-only}

The C-only interface is very similar:
\begin{verbatim}
    MPICommunicator mpi_comm;
    HYPRE_SStructMatrix   A;
    HYPRE_SStructGraph    graph;
    int object_type, var, nentries;
    int box_lower[3], box_upper[3], index[3];
    int *entries;

    HYPRE_SStructMatrixCreate( mpi_comm, graph, &A );

    /* HYPRE_SSTRUCT is the default, so we don't have to call SetObjectType */
    if ( object_type != HYPRE_SSTRUCT )
        HYPRE_SStructMatrixSetObjectType(A, object_type);
    HYPRE_SStructMatrixInitialize(A);

    /* SetBoxValues and SetValues are normally called inside loops */
    HYPRE_SStructMatrixSetBoxValues( A, part, box_lower, box_upper, var,
                                     nentries, entries, values );
    HYPRE_SStructMatrixSetValues
         ( A, part, index, var, nentries, entries, values )

    HYPRE_SStructMatrixAssemble(A);
\end{verbatim}


% >>>>>>>>>>>>>> Not done: vectors, stencils, graphs, grids, note that some
% have versions for different matrix storage types

% >>>>>>>>>>>>>> Not done: all solvers: PCG, GMRES, BiCGSTAB, CGNR, Euclid,
% Hybrid, ParaSails, Pilut, Schwarz, Split, and DiagScale, Identity;
%note that some have versions for different matrix storage types

\section{Building HYPRE with the Babel Interface}
\label{sec-Building-Babel}

You can build \hypre{} almost the same way with and without the
Babel-based interface.  Normally the only difference is that the
configure line needs an extra argument; for example:

\begin{verbatim}
    configure --with-babel
    make
\end{verbatim}
rather than
\begin{verbatim}
    configure
    make
\end{verbatim}

The configure system will enable whatever built-in languages it can
find compilers for.

The configure system for the runtime portion of Babel (included with
\hypre{} and enabled with the Babel-based interface) will
automatically compile and run a few tiny test programs.  This has been
a problem in multiprocessing AIX systems, where compiled programs are
normally run in a different environment from the configure system.
For AIX systems with POE, the
\hypre{} distribution includes a workaround script, \code{nopoe}.
When necessary, build \hypre{} as follows instead of the above:

\begin{verbatim}
    nopoe configure --with-babel
    make
\end{verbatim}

% I could write something about how building interfaces to other
% languages, but that may be too advanced for a user manual.
