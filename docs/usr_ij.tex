%==========================================================================
\chapter{The IJ Linear System Interface}
\label{IJ}

The IJ linear system (IJ) interface is the lowest common
denominator for specification of an 
unaugmented\footnote{An example of an augmented
linear system of equations would be a 
a linear system plus the stiffness matrices from which the matrix
coefficients are assembled in a finite element discretization.
More than the linear system of equations is provided.}
linear system of equations to be solved by {\slshape hypre}.
No {\itshape a priori} assumptions are made about the sparsity
pattern of a linear system passed through the IJ interface.
Like all {\slshape hypre} interfaces, it is designed
to insulate the user from underlying implementation details.

One would typically use the IJ interface to specify the linear
system originating from an unstructured grid PDE discretization.
However, the interface can be used for discretizations from more
structured grids, with consequent solver inefficiencies from lack
of built-in sparsity assumptions.

IJ matrix interface calls facilitate creation and destruction of 
matrix interface objects; specification, manipulation and retrieval
of rows and blocks of linear system coefficients; and determination
and querying of underlying linear system data structure formats.
{\slshape Hypre} supports multiple underlying data structure formats
in order to cooperate
with packages such as {\slshape PETSc} and {\slshape ISIS},
as well as for convenience to the {\slshape hypre} solver developer.
One format is abbreviated {\itshape ParCSR}, meaning {\itshape Par}allel
{\itshape C}ompressed {\itshape S}parse {\itshape R}ow.

IJ vector interface calls facilitate creation and destruction of
vector interface objects, as well as specification, manipulation,
and retrieval of right-hand side and initial guess vector components.

Currently, {\slshape hypre} solvers which operate directly on linear
systems passing through the IJ interface have either
{\itshape ParCSR} implementations, {\slshape ISIS} implementations,
or {\slshape PETSc} implementations.

A full listing of IJ linear system C-functions and Fortran
interface names should be located in the {\slshape hypre} reference
manual.

\section{IJ Matrix Interface}

Following are examples of function calls necessary for use of the
IJ matrix interface.  The variables and parameters in the
function calls would be associated with the following declarations:

\begin{verbatim}
  MPI_Comm communicator;
  HYPRE_IJMatrix *ij_matrix;
  int global_m, global_n, num_cols, row_index;
  int *col_indices;
  double *coeffs;
  int ierr;
\end{verbatim}

\noindent In reference to a row, variable \verb+num_cols+ specifies
the number of columns with nonzero entries.
Integer \verb+ierr+ carries program error state information. 

\subsection{Creation and destruction of interface object}

An IJ matrix interface object can be created and destroyed as
follows:
\begin{verbatim}
  ierr = HYPRE_IJMatrixCreate(communicator, &ij_matrix,
                              global_m, global_n);

  ierr = HYPRE_IJMatrixDestroy(ij_matrix);
\end{verbatim}
\noindent The \verb+MPI_Comm+ variable \verb+communicator+
is used to carry
interprocessor communication information needed by MPI.
Integers \verb+global_m+ and \verb+global_n+ specify the global
number of rows and columns in the coefficient matrix, over all processors.

\subsection{Typical implementation}

\begin{verbatim}
  ierr = HYPRE_IJMatrixCreate(communicator, &ij_matrix_ptr,
                              global_m, global_n);

  ierr = HYPRE_IJMatrixSetLocalStorageType(ij_matrix, type);
\end{verbatim}

\noindent Allowed storage types will be \verb+HYPRE_PARCSR+,
\verb+HYPRE_ISIS+, and \verb+HYPRE_PETSC+.  Currently, only
\verb+HYPRE_PARCSR+ has been tested. 

Once the matrix is initialized, repeated calls to
\verb+HYPRE_IJMatrixInsertRow+ can be used to communicate
the matrix coefficients.  Then a matrix assembly call stows
the coefficients in objects which the solvers can process. 

\begin{verbatim}
  ierr = HYPRE_IJMatrixInitialize(ij_matrix);

  ierr = HYPRE_IJMatrixInsertRow(ij_matrix, num_cols,
                                 row_index, col_indices, coeffs);

  ierr = HYPRE_IJMatrixAssemble(ij_matrix);
\end{verbatim}

\noindent Integer \verb+row_index+ is used to specify the global
number of the row being inserted.
\noindent Pointer \verb+coeffs+ would typically address an array of
\verb+num_cols+ doubles.
Pointer \verb+col_indices+ would typically
address an array of \verb+num_cols+ integers which specify the
matrix column in which each \verb+coeffs+ double belongs.  
Typically, linear systems involving the \verb+ij_matrix+
object are solved after this point.  After solution, the
\verb+ij_matrix+ should be deallocated if it is not to be reused:

\begin{verbatim}
   ierr = HYPRE_IJMatrixDestroy(ij_matrix);
\end{verbatim}

\section{IJ Vector Interface}

Following are examples of function calls necessary for use of the
IJ vector interface.  The variables and parameters in the
function calls would be associated with the following declarations:

\begin{verbatim}
   MPI_Comm communicator;
   HYPRE_IJVector *ij_vec, *ij_b, *ij_x;
   int domain_pt_start, next_domain_pt_start, ierr;
   int global_number_pts, num_components;
   int *glob_vec_indices, *b_indices, *x_indices;
   double *b, *b_plus, *x;
\end{verbatim}

\noindent Integers \verb+domain_pt_start+ and \verb+next_domain_pt_start+
specify the global indices of the first unknown on the local processor
and on the next processor in the domain decomposition, respectively.

\subsection{Creation and destruction of interface object}

An IJ vector object for the solution can be created and destroyed
as follows:
\begin{verbatim}
   ierr = HYPRE_IJVectorCreate(communicator, &ij_x, global_m);

   ierr = HYPRE_IJVectorDestroy(ij_x);
\end{verbatim}

\noindent As expected, the global number of components of the
vector is the same as the global number of rows in the matrix,
\verb+global_m+.
Similarly for the right-hand side IJ vector object to a linear
system.

\subsection{Typical setup of right-hand side and solution vectors}

\begin{verbatim}
   ierr = HYPRE_IJVectorCreate(communicator, ij_b, global_m);

   ierr = HYPRE_IJVectorSetLocalStorageType(ij_b, HYPRE_PARCSR);
\end{verbatim}

\noindent Allowed storage types will be \verb+HYPRE_PARCSR+,
\verb+HYPRE_ISIS+, and \verb+HYPRE_PETSC+.  Currently, only
\verb+HYPRE_PARCSR+ has been tested.  Processors can be informed
about distribution of unknowns over processors,

\begin{verbatim}
   ierr = HYPRE_IJVectorSetLocalPartitioning(ij_b, domain_pt_start,
                                             next_domain_pt_start);
\end{verbatim}

\noindent and then all processors must agree upon the distribution, ...

\begin{verbatim}
   ierr = HYPRE_IJVectorAssemble(ij_b);
\end{verbatim}

\noindent Memory space is then allocated for the vector components
that must be handled on the processor, ...

\begin{verbatim}
   ierr = HYPRE_IJVectorInitialize(ij_b);          
\end{verbatim}

\noindent The same should be done for the solution vector:

\begin{verbatim}
   ierr = HYPRE_IJVectorCreate(communicator, ij_x, global_m);

   ierr = HYPRE_IJVectorSetLocalStorageType(ij_x, HYPRE_PARCSR);

   ierr = HYPRE_IJVectorSetLocalPartitioning(ij_x, domain_pt_start,
                                             next_domain_pt_start);

   ierr = HYPRE_IJVectorAssemble(ij_x);

   ierr = HYPRE_IJVectorInitialize(ij_x);
\end{verbatim}

\noindent Vector components can be placed into underlying
{\slshape hypre} formats either in contiguous subsets or in
indexed subsets (shown for \verb+ij_b+ only) ...

\begin{verbatim}
   ierr = HYPRE_IJVectorSetLocalComponentsInBlock(ij_b,
                                      glob_vec_index_start,
                                      glob_vec_index_stop,
                                      b_indices, b);
\end{verbatim}
\begin{verbatim}
   ierr = HYPRE_IJVectorSetLocalComponents(ij_b, num_components,
                                      glob_vec_indices,
                                      b_indices, b);
\end{verbatim}

\noindent To assign values to all components in a domain, one would
choose \verb+glob_vec_index_start+ \verb+=+ \verb+domain_pt_start+,
and \verb+glob_vec_index_stop+ \verb+=+\verb+next_domain_pt_start-1+.

\begin{figure}[b]
\label{loc_comps_map}
\centerline{\epsfig{figure=loc_comps.eps,height=2.5in}}
\parbox{6in}{\hspace{1in}
             {\tt ierr = HYPRE\_IJVectorSetLocalComponents(ij\_vec,}}
\parbox{6in}{\hspace{4.15in}
             {\tt num\_values,}}
\parbox{6in}{\hspace{4.15in}
             {\tt glob\_vec\_indices,}}
\parbox{6in}{\hspace{4.15in}
             {\tt value\_indices,}}
\parbox{6in}{\hspace{4.15in}
             {\tt values);}}
\caption{Mapping between underlying vector data and external
    array values}
\end{figure}

One can also add to vector components that are already set, in
contiguous or indexed subsets of components.
In the following example,
assume that array \verb+b_plus+
contains values to be added to components of \verb+ij_b+:

\begin{verbatim}
   ierr = HYPRE_IJVectorAddToLocalComponentsInBlock(ij_b,
                                      glob_vec_index_start,
                                      glob_vec_index_stop,
                                      b_indices, b_plus); 
\end{verbatim}
\begin{verbatim}
   ierr = HYPRE_IJVectorAddToLocalComponents(ij_b, num_components,
                                      glob_vec_indices,
                                      b_indices, b_plus);
\end{verbatim}

\noindent After the solver is finished, solution vector components
can be extracted from a contiguous or an indexed subset of
the underlying vector data array, ...

\begin{verbatim}
   ierr = HYPRE_IJVectorGetLocalComponentsInBlock(ij_x,
                                      glob_vec_index_start,
                                      glob_vec_index_stop,
                                      x_indices, x);
\end{verbatim}
\begin{verbatim}
   ierr = HYPRE_IJVectorGetLocalComponents(ij_x, num_components,
                                      glob_vec_indices,
                                      x_indices, x);
\end{verbatim}

\noindent After the solution vector is communicated through the interface,
the interface should be deallocated if it is not to be reused.

\begin{verbatim}
   ierr =  HYPRE_IJVectorDestroy(ij_b);
   ierr =  HYPRE_IJVectorDestroy(ij_x);
\end{verbatim}



