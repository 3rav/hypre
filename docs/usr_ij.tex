%==========================================================================
\chapter{Linear-Algebraic System Interface (IJ)}
\label{Linear-Algebraic System Interface}

The \code{IJ} interface described in this chapter is the lowest common
denominator for specifying linear systems in \hypre{}.  This interface
provides access to general sparse-matrix solvers in \hypre{}, but not
to the specialized solvers that require more problem information.

%==========================================================================

\section{IJ Matrix Interface}

The following example code illustrates the basic usage of the
\code{IJ} interface for building matrices:
\begin{display}
\begin{verbatim}

MPI_Comm        comm;
HYPRE_IJMatrix  ij_matrix;
int             global_m, global_n;
int             num_values;
int             row;
int            *cols;
double         *values;

HYPRE_IJMatrixCreate(comm, &ij_matrix, global_m, global_n);
HYPRE_IJMatrixSetLocalStorageType(ij_matrix, HYPRE_PARCSR);
HYPRE_IJMatrixInitialize(ij_matrix);

/* set matrix coefficients a row at a time */
HYPRE_IJMatrixSetValues(ij_matrix, num_values, row, cols, values);
...

HYPRE_IJMatrixAssemble(ij_matrix);

\end{verbatim}
\end{display}
The \code{Create()} routine creates an empty \code{global_m} by
\code{global_n} matrix object that lives on the \code{comm} communicator.
The \code{SetLocalStorageType} routine sets the underlying matrix
storage type to \code{HYPRE_PARCSR} (this is the only storage type
currently supported).  The \code{Initialize()} routine indicates that
the matrix coefficients (or values) are ready to be set.  This routine
may or may not involve the allocation of memory for the coefficient
data, depending on the implementation.  The optional \code{Set}
routines mentioned later in this chapter and in the Reference Manual,
should be called before this step.  The \code{SetValues()} routine
sets the matrix coefficients for a specified \code{row} and list of
\code{cols} (\code{num_values} is the number of column coefficients being set).
The \code{Assemble()} routine is a collective call (i.e., must be
called on all processes), and finalizes the matrix assembly, making
the matrix ``ready to use''.

%\begin{figure}
%\begin{center}
%\newcommand{\qq}{\scriptstyle}
%\renewcommand{\arraycolsep}{4 pt}
%\renewcommand{\arraystretch}{0.5}
%\begin{equation}
%\left(
%\begin{array}{ c|c c c c c|c c c c c|c c c c c|c }
% & & & & & & & &\qq \; & & & & & & & & \\
% & & & & & & & &\qq \vdots & & & & & & & & \\
%\hline
% & & & & & & & &\qq \vdots & & & & & & & & \\
%\qq .\,.\,.\; &\qq \; &\qq \; &\qq a &\qq \; &\qq \; &
%\qq \! & \qq a &\qq a &\qq a &\qq \; &
%\qq \; &\qq a &\qq \; &\qq \; &\qq \; &\qq \; .\,.\,.\\
% & & & & & & & &\qq \vdots & & & & & & & & \\
% & & & & & & & &\qq \; & & & & & & & & \\
%\hline
% & & & & & & & &\qq \vdots & & & & & & & \\
% & & & & & & & &\qq \; & & & & & & & & \\
%\end{array}
%\right)
%\left(
%\begin{array}{c}
%\qq x \\
%\qq \vdots \\
%\\
%\\
%\\
%\\
%\qq \vdots \\
%\\
%\qq x \\
%\end{array}
%\right)
%=
%\left(
%\begin{array}{c}
%\qq \;\\
%\qq \vdots \\
%\hline
%\qq \vdots \\
%\qq b \\
%\qq \vdots \\
%\qq \;\\
%\hline
%\qq \vdots \\
%\qq \; \\
%\end{array}
%\right)
%\end{equation}
%\caption{Single row of a distributed system of equations.
%Interprocessor boundaries are marked by horizontal lines.
%Nonzero matrix coefficients are here indistinguishably
%expressed as {\it a}'s.  Unknown and right-hand side
%vectors are similarly expressed.}
%\end{center}
%\end{figure}
%
%\begin{figure}
%\label{fig-set-values}
%\centerline{\epsfig{figure=insert_row.eps,height=2.2in}}
%\vspace{0.15in}
%\parbox{6.5in}{\hspace{0.5in}
%  {\tt int HYPRE\_IJMatrixInsertRow(HYPRE\_IJMatrix *ij\_matrix,
%   int num\_cols, }}
%\parbox{6.5in}{\hspace{1.5in}
%  {\tt int row\_index, int *col\_indices, double *coeffs);}}
%\vspace{0.in}
%\caption{Array layout for {\tt HYPRE\_IJMatrixInsertRow}.}
%\end{figure}

%==========================================================================

\section{IJ Vector Interface}

The following example code illustrates the basic usage of the
\code{IJ} interface for building vectors:
\begin{display}
\begin{verbatim}

MPI_Comm        comm;
HYPRE_IJVector *ij_vector;
int             global_n;
int             num_values;
int            *global_indices;
int            *value_indices;
double         *values;

HYPRE_IJVectorCreate(comm, &ij_vector, global_n);
HYPRE_IJVectorSetLocalStorageType(ij_vector, HYPRE_PARCSR);
HYPRE_IJVectorInitialize(ij_vector);

/* set vector values */
HYPRE_IJVectorSetLocalComponents(ij_vector, num_values,
                                 global_indices, value_indices, values);
...

HYPRE_IJVectorAssemble(ij_vector);

\end{verbatim}
\end{display}
The \code{Create()} routine creates an empty \code{global_n}-vector
object that lives on the \code{comm} communicator.  The
\code{SetLocalStorageType} routine sets the underlying vector storage
type to \code{HYPRE_PARCSR} (this is the only storage type currently
supported).  The \code{Initialize()} routine indicates that the vector
coefficients (or values) are ready to be set.  This routine may or may
not involve the allocation of memory for the coefficient data,
depending on the implementation.  The optional \code{Set} routines
mentioned later in this chapter and in the Reference Manual, should be
called before this step.  The \code{SetLocalComponents()} routine sets
the vector coefficients for a specified list of \code{global_indices}
(\code{num_values} is the number of values being set).  The \code{Assemble()}
routine is a collective call (i.e., must be called on all processes),
and finalizes the vector assembly, making the vector ``ready to use''.

%In general, vector components can be placed into underlying \hypre{}
%formats either in contiguous subsets (Figure \ref{loc_comps_blk}) or
%in indexed subsets (Figure \ref{loc_comps}).
%\begin{figure}
%\label{loc_comps_blk}
%\centerline{\epsfig{figure=loc_cmps_blk.eps,height=2.5in}}
%\caption{Mapping between external array values and
%  internal vector data for \code{LocalComponentsInBlock} functions.}
%\end{figure}
%\begin{figure}
%\label{loc_comps}
%\centerline{\epsfig{figure=loc_cmps.eps,height=2.4in}}
%\caption{Mapping between external array values and
%   internal vector data for \code{LocalComponents} functions.}
%\end{figure}
