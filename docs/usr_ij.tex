%==========================================================================
\chapter{The IJ Linear System Interface}
\label{IJ}

The {\bf IJ linear system (IJ)} interface is the lowest common
denominator
for enumeration of an {\bf unaugmented} linear system of equations
to be solved by {\slshape hypre} and cooperative packages.
No underlying assumptions are made about the sparsity pattern of
a linear system passed through the IJ interface.
Like all Hypre interfaces, it is designed
to insulate the user from underlying implementation details.

Just to define an {\bf augmented} linear system, an example would be
a linear system plus the stiffness matrices from which the matrix
coefficients are assembled in a finite element discretization.
It contains more information than just the linear system
of equations.

One would typically use the IJ interface to enumerate the linear
system originating from an unstructured grid PDE discretization.
However, the interface can be used for discretizations from more
structured grids, with consequent solver inefficiencies from lack
of built-in sparsity assumptions.

IJ Matrix interface calls facilitate creation and destruction of 
interface objects, enumeration of rows and blocks of
linear system coefficients, and determination and querying of
underlying linear system data structure formats.  Hypre supports
multiple underlying data structure formats in order to cooperate
with packages such as PETSc and ISIS, as well as for convenience
to the {\slshape hypre} solver developer.
One format is abbreviated {\bf ParCSR}, meaning {\bf Par}allel
{\bf C}ompressed {\bf S}parse {\bf R}ow.  Another format
is DistributedMatrix.

Currently, {\slshape hypre} solvers which operate directly on linear
systems passing through the IJ interface have either
ParCSR (interface) implementations, or DistributedMatrix
implementations.

\section{IJ Matrix Interface}

\section{IJ Vector Interface}

Fortran implementation (temporarily):

      call HYPRE_IJVectorCreate(rad_comm, hypre_b, global_number_pts,
     &                          ierr)

      call HYPRE_IJVectorSetLocalStorageTy(hypre_b, HYPRE_PARCSR, ierr)

Processors can be informed about distribution of unknowns over processors,

      call HYPRE_IJVectorSetLocalPartition(hypre_b, domain_pt_start,
     &                                     next_domain_pt_start,
     &                                     ierr)

and then all processors must agree upon the distribution, ...

      call HYPRE_IJVectorAssemble(hypre_b, ierr)                     .

Memory space is then allocated for the vector components that must
be handled on the processor, ...

      call HYPRE_IJVectorInitialize(hypre_b, ierr)                   .

      call HYPRE_IJVectorCreate(rad_comm, hypre_x, global_number_pts,
     &                          ierr)

      call HYPRE_IJVectorSetLocalStorageTy(hypre_x, HYPRE_PARCSR,
     &                                     ierr)

      call HYPRE_IJVectorSetLocalPartition(hypre_x, domain_pt_start,
     &                                     next_domain_pt_start,
     &                                     ierr)

      call HYPRE_IJVectorAssemble(hypre_x, ierr)

      call HYPRE_IJVectorInitialize(hypre_x, ierr)


Vector components can be placed into underlying Hypre formats either
in contiguous subsets, ...

      call HYPRE_IJVectorSetLocalCompsInBl(hypre_b,
     &                                     domain_pt_start,
     &                                     next_domain_pt_start-1,
     &                                     ii,y,ierr)

      call HYPRE_IJVectorSetLocalCompsInBl(hypre_x,
     &                                     domain_pt_start,
     &                                     next_domain_pt_start-1,
     &                                     ii,x,ierr)

or in indexed subsets

      call HYPRE_IJVectorSetLocalComps(hypre_b,
     &                                 domain_pt_start,
     &                                 next_domain_pt_start-1,
     &                                 ii,y,ierr)

      call HYPRE_IJVectorSetLocalComps(hypre_x,
     &                                 domain_pt_start,
     &                                 next_domain_pt_start-1,
     &                                 ii,x,ierr)                   .

After the solver is finished, vector components can be extracted from
a contiguous subset of components, ...

      call HYPRE_IJVectorGetLocalCompsInBl(hypre_x,
     &                                     domain_pt_start,
     &                                     next_domain_pt_start-1,
     &                                     ii, x, ierr)

or from an indexed subset of components, ...

      call HYPRE_IJVectorGetLocalCompsInBl(hypre_x,
     &                                     num_values,
     &                                     ii, x_indices, x, ierr)  .

One can also add to vector components that are already set.

