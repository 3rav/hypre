%=============================================================================
%=============================================================================

\chapter{Babel Interface}
\label{ch-babel}

\section{Introduction}

The ``Babel interface'' is an interface to \hypre{} which uses Babel,
\url{http://www.llnl.gov/CASC/components/index.html}, for language
interoperability.  Our users can write code in the language of their
choice. In this language, \hypre{} will look like a native - with
appropriate class declarations, function calls, etc.

We start by defining a generic object-oriented interface to \hypre{},
using the object-oriented SIDL language.  It's all in the file
\code{babel/Interfaces.idl}.  Babel compiles this into ``glue'' code.  This
includes ``server'' code which calls \hypre{} functions, and one set
of ``client'' code for each language in which users might want to
call \hypre{}.

When the user calls \hypre{} through the Babel interface, he calls a
function or method declared in his language and generated by Babel.
This function calls a variety of other functions, which eventually
call the server code, and thus \hypre{}.  The intermediate functions
include, not only the generated functions, but also more generic
``runtime'' functions, located in the \code{babel-runtime} directory
of \hypre{}.

For more information about Babel, consult the Babel Users' Guide,
\url{http://www.llnl.gov/CASC/components/docs/users_guide/users_guide.html},
or one of the other publications of the Babel group,
\url{http://www.llnl.gov/CASC/components/docs.html}.


With Babel doing all the work of connecting languages to each other,
what do we, as \hypre{} developers, have to do?
\begin{list}{\arabic{enumi}.}{\usecounter{enumi}\setlength{\itemsep}{0in}}
\item Define the \hypre{} interface.  (Changes to the interface must
be coordinated with the project leader.)
\item Run Babel to generate the ``glue'' code.
\item Write the ``implementations'', the server-side functions which
call the actual \hypre{} functions.
\item Write test and example programs.
\item Get everything to build right.
\item Write documentation and adjust code as needed so our
documentation system will work.
\end{list}

\section{First, try it out}

To build \hypre{} with the Babel interface, configure with the
\code{--with-babel} option and run \code{make}.  The Babel interface
is off by default because the configure and build system take extra
time.

Once you have done this, look at the example programs.  Most can be
built and run the usual way, e.g. \code{make ex5b; ./ex5b}.  Some are
more complicated to use and may require you to first install some
support software.  For details, see the comments at the top of each
example.

\section{Define the \hypre{} interface}

The \hypre{} interface is defined for Babel by the file
\code{Interfaces.idl}.  The language of this file is SIDL, ``Scientific
Interface Definition Language'', an extension of IDL.  This is an
object-oriented language similar to Java.  For more information on the
language, see the Babel Users' Guide,
\url{http://www.llnl.gov/CASC/components/docs/users_guide/users_guide.html}.

The interface and class structure in Interfaces.idl follow the
conceptual object structure which lies behind \hypre{}.  This
structure is discussed in Section 8.9 of the \hypre{} User's Manual,
and various papers such as \cite{EChow_AJCleary_RDFalgout_1998} and
\cite{RDFalgout_JEJones_UMYang_2005a}.

\section{Run babel}

First, of course, you need Babel.  Download it from the Babel web
site.  Note that the version of Babel which you run should be the same
as the version which contributed the \code{babel-runtime} directory.
You can check the version numbers by typing \code{configure --version}
in the appropriate directories, or \code{babel --version}.

A script, \code{babel-runall}, will run Babel to generate most of the
code in directories \code{babel/bHYPRE} and
\code{babel/bHYPREClient-*}.  The script has a line for Fortran 90
which is commented-out because most \hypre{} developers do not have a
Fortran 90 compiler in their path.

Besides running Babel, \code{babel-runall} does a few things to fix up
the results of a Babel run so our documentation generator will work.

\section{Implementations}

The part of the Babel system that calls \hypre{} is in the directory
\code{babel/bHYPRE}.  Every file there, other than the \code{Makefile}, is at
least partly generated by Babel.  The only hand-written code is found
in the``impls'', files whose names end with
\code{_Impl.c} or \code{_Impl.h}.  Each impl is for one Babel class.
For an impl, Babel generates an outline.  Then you write the
implementation of the class; i.e., declare its data members in the
\code{_Impl.h} file and each of its function members in the
\code{_Impl.c} file. Put your code within the ``splicer blocks'' so it
will be preserved the next time Babel gets run.  Comments clearly mark
each splicer block.

It is possible to write an entire solver in an impl; for example, see
\code{bHYPRE_PCG_Impl.c}.  But usually one interfaces to an existing
\hypre{} solver.  The present \code{bHYPRE} directory has plenty of
examples of this!

Typically, an interface function extracts data from a Babel-interface
object, described in an \code{_Impl.h} file, and uses it to call a
\code{HYPRE_} function.  Several complexities crop up from time to
time.  For example, the necessary conversions often involve creating
Babel objects, so you have to take some care with memory management.
The rest of this section will call attention to some of the other
issues to watch for.

The SIDL language, like Java, distinguished between interfaces and
classes.  An interface has only function prototypes.  A class contains
data and implements the functions.  This is important for writing the
implementation of a function because the declared data type of a
function argument may be just an interface.  With no data you can't
extract a \hypre{} object from it or do much else.  Before doing
anything with such an argument, you have to cast it to a specific
class.  Sometimes you may have to try several casts, and use the data
type for which the cast succeeds.

Most \hypre{} arrays are one-dimensional.  For them, Babel's
\code{rarray} (raw array) type works well.  That means that the user
can use his language's native array type and Babel provides the impls
with C arrays.  Two-dimensional arrays generally have to be passed
through as \code{sidl} arrays.  The user has to construct them, as
described in the Babel Users' Manual, and we have to extract and
convert their contents for \hypre{} use.

All Babel-generated functions support the Babel exception handler.
For the impls, that means an extra argument.  We deal with errors
differently in \hypre{}, but often the impls call other
Babel-generated functions, so they need a little basic coding to
support the exception handler.  See any \code{_Impl.c} for examples.

The greatest interface difficulty we have lies in the MPI
communicator.  We have isolated the difficulties in one place:
creation of our \code{MPICommunicator} object.  The user has to be the
one to set up an MPI communicator and pass it to \hypre{}.  In the
user's code, the communicator is declared and defined by some external
library.  In C and Fortran it is a handle or pointer to a struct, but
in other languages it can be an instance of a class, for example.  The
MPI-2 standard provides a way to convert between C and Fortran
communicators, but in other languages the MPI library's API may
provide no way to convert its MPI communicator type to anything else.
Babel provides a facility, the \code{opaque} data type, to pass an
arbitrary object from the user's code to the impls.  That is how the
user gives us the MPI communicator, but that leaves us with the job of
determining the language, the MPI library, and the data type of the
user's MPI communicator; and then the job of converting that to a C
MPI communicator with absolute reliability.  At present there are
separate functions for creating an \code{MPICommunicator} object from
C and Fortran specifications of the communicator, and a simple
function to create a \code{MPI_COMM_WORLD} object without any inputs.

Many of the \hypre{} interface include files must be made available to
the user.  The make system copies them to \code{hypre/include}.

\section{Example and test programs}

The present example and test programs for the Babel interface closely
follow example and test programs for the native interface.  See the
Hypre Users' Manual for a discussion of the similarities and differences in
how \hypre{} is used with these two code interfaces.  As you would
expect, the class structure of \hypre{} is more apparent when \hypre{}
is used in an object-oriented language.

\section{Building}

The build system for the Babel interface is integrated with \hypre{}'s
regular build system.  Configure \code{--with-babel} and \code{make}
as usual.  There are, however, a number of special features and
difficulties.  See the following sections on the Babel runtime system,
include files, and particular languages with special needs.

The makefiles are hand-written but each imports lists of generated files
from an automatically generated file named \code{babel.make}.

\section{Documentation generation}

The \code{doc++} system used for \hypre{} documentation picks up
comments in Babel-generated code.  Most of these comments were not
really generated; Babel copies them from the file
\code{Interfaces.idl}, which we write.

Some of the Babel-generated comments are not quite right for
\code{doc++}.  The script \code{babel-runall} will fix some of the
difficulties, and comments in the script give instructions for doing
some other fixes by hand.

\section{Babel runtime}

The directory \code{babel-runtime} contains exactly the same files as the
Babel distribution's directory \code{runtime}, plus a file
\code{HYPRE_README.txt}.

This Babel runtime directory has its own configure and build system.
But don't run its configure script directly.  If you let the \hypre{}
configure script run it, then the Babel runtime will be generated to
be consistent with \hypre{} , e.g. C binaries will come from the same
compiler.

The Babel runtime configure system tries to compile and run some
little test programs.  This can be a problem on some large computers
where programs are normally run under a batch system, but compilers
and the like are normally run under an interactive system which
behaves differently.  The script \code{nopoe} works around this
problem on AIX systems.  For example, rather than \code{configure
--with-babel}, type
\code{nopoe configure --with-babel}.

It is important that the Babel runtime directory come from the same
version of Babel that is run to generate the Babel interface.
Although the directory is copied from Babel, we maintain it in
\hypre{}'s CVS version control system.  To upgrade the Babel version,
make a backup copy of \code{babel-runtime}, copy the directory tree
from the Babel distribution, and tell CVS to add or remove files as
necessary.

A few files in \code{babel-runtime/sidl} refer to
\code{SIDL_DEBUG_REFCOUNT}.  If you \code{#define} this variable,
Babel will print a very useful memory management log.  This is all you
need to debug any memory management problems related to your use of
Babel's memory system.

\section{Include files}

The users may need many of the include files which Babel generated for the language
interfaces.  The present build system copies them to
\code{hypre/include} for C, C++, and Fortran.  The user must put the
appropriate language interface directory in his include path for
Fortran 90.  See below for a discussion of building with Python.
 The suffixes Babel uses for include files are:
\begin{list}{\arabic{enumi}.}{\usecounter{enumi}\setlength{\itemsep}{0in}}
\item \code{C: .h}
\item \code{C++: .hxx}
\item \code{Fortran 77: .inc}
\item \code{Fortran 90: .F90}
\end{list}

\section{Fortran 90}

At present (September 2007), CASC workstations do not support Fortran
90.  But even without a Fortran 90 compiler, Babel can generate
correct Fortran 90 glue code which can be distributed to Fortran 90
users.

But if you want to test the Fortran 90 interface on CASC workstations,
you will have to download and install a Fortran 90 compiler, an MPI
library which supports Fortran 90 (look for \code{.mod} files and a
\code{mpif90} compiler wrapper), and Chasm (for information about
Chasm see the Babel Users' Guide).  Set the environment variable
\code{FC} to your \code{mpif90}, and \code{CHASMPREFIX} to the \code{--prefix}
option used in configuring Chasm.  Then the usual \code{configure} and
\code{make} process will set up \hypre{} so you can link it to a
Fortran 90 code with the Fortran 90 interface.

\section{Python}

Building the Python interface is very different from building the
interface to compiled languages.

Build requirements:
\begin{list}{\arabic{enumi}.}{\usecounter{enumi}\setlength{\itemsep}{0in}}
\item Use a recent version of Python
\item Python requires shared libraries, so \hypre{} must be configured
with \code{--enable-shared}.
\item The Python interface takes a while to build, so it is off by
default.  To build it, configure \hypre{} with \code{--enable-python};
but see the next item.
\item Install pyMPI.  Configure \hypre{} with \code{--enable-python=pyMPI} so
this is the Python which gets hooked up to \hypre{}.
\item Install whichever numeric extension of Python is required by the
current version of Babel; see the Babel Users' Guide
\item Environment variables, where \code{<hypre>} is your top-level
\hypre{} directory:
 \newline
 \code{SIDL_DLL_PATH=<hypre>/babel/bHYPREClient-P/libbHYPRE.scl}
 \newline
  \code{LD_LIBRARY_PATH=<hypre>/hypre/lib}
\end{list}

Although the Python directory contains a \code{Makefile}, the main
thing it does is run the Python setup system. The file which really
does the building is \code{setup.py}. The setup process will put some
\hypre{} libraries in a Python directory.  Note that the \hypre{}
build system doesn't know about this.  So if you change \hypre{} you
will need to re-run the Python setup system to bring the Python
interface up-to-date.

The other non-generated file in the Python directory
\code{bHYPREClient-P} is a \code{.scl.in} file.  This is used to
generate a \code{.scl} file, which tells the Python system how to load
the Babel objects representing \hypre{}.

\section{Java}

The Java interface is still being tested.  It is built with a regular
\code{Makefile}, but like the Python interface needs an \code{.scl} file and
environment variables.  See the Java example program \code{ex5bj} for
the latest information.

