%==========================================================================
\chapter{Introduction}
\label{Introduction}

\hypre{} is a software library focused on the solution of large, sparse linear
systems of equations on highly parallel distributed-memory computer
systems. The library has been created with the goals of robustness,
computational performance, ease of use, flexibility, and interoperability
with other similar libraries. The mathematical emphasis is to provide
the latest scalable preconditioner algorithms to application codes
with a minimum of delay between development and deployment.

\section{Overview}

The following is a high-level list of the major features, assumptions and
limitations, and modes of use of 
\hypre{}. All of these subjects will be discussed in more detail later in this
User's Guide.

\subsection{Features}

\begin{itemize}

\item
{\bf Scalable Preconditioners Provide Efficient Solution on Today's and Tomorrow's
Systems:} \hypre{} 
contains several families of complex preconditioner algorithms focused on the
scalable solution of very 
large sparse linear systems. \hypre{} includes algorithms that other
general-purpose libraries cannot, such as 
structured multigrid, through the use of the Grid-centric interfaces discussed
below. These interfaces 
provide more information to solvers than traditional sparse matrix data
structures can provide, enabling 
more effective algorithms.

\item
{\bf Suite of Common Iterative Methods Provides Options for a Spectrum of Problems:}
\hypre{} provides 
an assortment of the most widely used Krylov-based iterative methods to be used
in conjunction with the 
scalable preconditioners. This includes general methods such as GMRES and
methods specialized for 
symmetric matrices such as Conjugate Gradient.

\item
{\bf Intuitive Grid-Centric Interfaces Obviate Need for Complex Data Structures:}
\hypre{} has made a 
major step forward in usability from earlier generations of sparse linear
solver libraries in that users do not 
have to learn complicated sparse matrix data structures. Instead, \hypre{} does
the work of building these 
data structures for the user through a variety of interfaces, each appropriate
to different classes of users. 
These include a structured, stencil-based interface most appropriate for
finite-difference applications; an 
unstructured finite-element based interface; and a linear-algebra based
interface. Other interfaces will be 
added as time and demand dictate.
Each interface provides access to several solvers without the need to
write new interface code.

\item
{\bf Many User Options Accommodate Beginners through Experts:} \hypre{} allows a
spectrum of expertise 
to be applied by users. The beginning user can get up and running with a
minimal amount of effort. More expert users can take further
control of the solution process 
through various parameters, all of which have reasonable defaults. 
%Further expertise can 
%allows users to put together their own solvers using components of \hypre{} as
%"building blocks", a 
%technique enabled through a new, flexible object model for linear solver
%libraries.

\item
{\bf Many Configuration Options to Suit your Computing System:} \hypre{} utilizes the
autoconf package to 
allow simple and flexible installation on a wide variety of computing systems.
Users can tailor the 
installation to match their computing system. Options include debug and
optimized modes, modes for 
including components from other installed linear solver libraries such as PETSc
and ISIS++ (see below), 
the ability to change dependent libraries such as MPI and BLAS, a
serial-machine mode, and modes 
enabling threads for certain solvers. On most systems, however, \hypre{} can be
built by simply typing 
"configure" followed by "make".

\item
{\bf Compatibility/Interoperability with Other Libraries Allows Plug and Play with
and Importing from 
other major solver libraries:} \hypre{} has been co-designed with the Equation
Solver Interface forum, a 
consortium of developers of sparse linear system libraries. The goal of the
forum is to design standard 
interfaces for these libraries that allow them to be compatible and
interoperable with each other. This 
process is ongoing, but it already allows \hypre{} users to invoke solvers and
preconditioners from libraries 
such as PETSc, ISIS++, and Aztec, oftentimes mixing and matching elements from
one library with 
elements from another. This provides a huge increase in options for users so
that they can find the unique 
combination that works best for them.

\item
{\bf Interfaces in Multiple Languages Provide Greater Flexibility for Applications:}
\hypre{} contains 
interfaces for both Fortran and C users.
%another major breakthrough in flexibility and usability: it is callable from a
%wide variety of languages. We 
%have used the Babel project to provide interfaces in C, C++, and Fortran, and
%as Babel adds support for 
%other languages, those languages will be added to \hypre{}. Babel allows \hypre{} to
%use an object-oriented 
%design in each of the supported languages, thus eliminating the need for \hypre{}
%to be written to the so-
%called "lowest common denominator".

\end{itemize}

\subsection{Assumptions and Limitations}

{\bf \hypre{} is designed for large, sparse, linear systems on parallel
computers.}  Small linear systems, 
systems that are solvable on a sequential computer, and dense systems are all
better addressed by libraries designed specifically for them. 

{\bf \hypre{} requires an installation of the Message Passing Interface (MPI).}
Exception: will run 
sequentially (for debugging) with an included "stub" version of MPI.

{\bf Configuration of \hypre{} with threads
requires an implementation of the Open MP standard.}
Only a small set of \hypre{} is compatible with threads at the current time.

{\bf Configuration of \hypre{} with other libraries requires installation of and
linking to those libraries.}

{\bf \hypre{} is a project under construction.} Systems problems, SAMR interface,
semi-structured interface, 
AMGe, full object orientation, full multilanguage support, ESI not integrated
yet, etc.




\section{General Structure of Usage}

Give example code here, maybe Rob's structured example is clearest. Use it to
demonstrate basic structure of usage:  This be temporarily yucky -MAL

\begin{display}
\begin{verbatim}

/*-----------------------------------------------------------
 * Set up the matrix
 *-----------------------------------------------------------*/

   HYPRE_StructGridCreate(MPI_COMM_WORLD, dim, &grid);

   /* Use HYPRE_StructGridSetExtents to define index space of
      each block of the grid */

   HYPRE_StructGridSetPeriodic(grid, periodic);
   HYPRE_StructGridAssemble(grid);
	
   HYPRE_StructStencilCreate(dim, dim + 1, &stencil);

   /* Use HYPRE_StructStencilSetElement to impart structure to stencil */

/* Use grid and stencil to set matrix structure on matrix creation */
   HYPRE_StructMatrixCreate(MPI_COMM_WORLD, grid, stencil, &A);

   HYPRE_StructMatrixSetSymmetric(A, 1);
   HYPRE_StructMatrixSetNumGhost(A, A_num_ghost);
   HYPRE_StructMatrixInitialize(A);

   /* Use HYPRE_StructMatrixSetBoxValues to set coefficients
      of matrix A */

   HYPRE_StructMatrixAssemble(A);

/*-----------------------------------------------------------
 * Set up the right-hand side and initial guess
 *-----------------------------------------------------------*/

   HYPRE_StructVectorCreate(MPI_COMM_WORLD, grid, stencil, &b);
   HYPRE_StructVectorInitialize(b);

   /* Use HYPRE_StructVectorSetBoxValues to set values of
      right-hand side b */

   HYPRE_StructVectorAssemble(b);

   HYPRE_StructVectorCreate(MPI_COMM_WORLD, grid, stencil, &x);
   HYPRE_StructVectorInitialize(x);

   /* Use HYPRE_StructVectorSetBoxValues to set values of
      initial guess x */

   HYPRE_StructVectorAssemble(x);

/*-----------------------------------------------------------
 * Set up solver
 *-----------------------------------------------------------*/

   HYPRE_StructPFMGCreate(MPI_COMM_WORLD, &solver);

/* Set solver parameters */
   HYPRE_StructPFMGSetMaxIter(solver, 50);
   HYPRE_StructPFMGSetTol(solver, 1.0e-06);
   HYPRE_StructPFMGSetRelChange(solver, 0);
   HYPRE_StructPFMGSetRelaxType(solver, 1);
   HYPRE_StructPFMGSetNumPreRelax(solver, n_pre);
   HYPRE_StructPFMGSetNumPostRelax(solver, n_post);
   HYPRE_StructPFMGSetSkipRelax(solver, skip);
   HYPRE_StructPFMGSetLogging(solver, 1);

   HYPRE_StructPFMGSetup(solver, A, b, x);

/*-----------------------------------------------------------
 * Solve the linear system
 *-----------------------------------------------------------*/

   HYPRE_StructPFMGSolve(solver, A, b, x);

/*-----------------------------------------------------------
 * Get solver results
 *-----------------------------------------------------------*/

/* Get solver statistics */
   HYPRE_StructPFMGGetNumIterations(solver, &num_iterations);
   HYPRE_StructPFMGGetFinalRelativeResidualNorm(solver, &final_res_norm);

/* Get solution */
  /* Use HYPRE_StructVectorGetBoxValues to get solution into simple
     arrays */

/*-----------------------------------------------------------
 * Deallocate solver memory space 
 *-----------------------------------------------------------*/
   HYPRE_StructPFMGDestroy(solver);

/*-----------------------------------------------------------
 * Deallocate linear system memory space 
 *-----------------------------------------------------------*/
   HYPRE_StructGridDestroy(grid);
   HYPRE_StructStencilDestroy(stencil);
   HYPRE_StructMatrixDestroy(A);
   HYPRE_StructVectorDestroy(b);
   HYPRE_StructVectorDestroy(x);

\end{verbatim}
\end{display}


{\bf \it Before coding:}

\begin{enumerate}

\item
{\bf Choose a conceptual interface.} Generally, the choice is fairly obvious, as,
say, a structured grid 
interface is clearly inappropriate from an unstructured grid application. It is
desirable to use a more 
specific interface if appropriate, e.g., the linear-algebraic interface is
usable from any type of grid but 
will involve much more user work and prevent access to some grid-type-specific
preconditioners.

\item 
{\bf Choose a desired solver/preconditioner combination.} For the typical user,
this will mean a single 
Krylov method and a single preconditioner. Some common combinations have been
prewrapped as a 
single solver to make them easier to use. 
%More advanced users might choose to,
%say, use two 
%preconditioners, composed through residual correction, to create a more robust
%solution method.

\item 
{\bf Look up matrix requirements for each solver and preconditioner.} Each
specific solver and 
preconditioner ("Operator") has requirements from the input matrix. Some only
work with specific 
matrix types, while others can work with any matrix that provides certain
"services" (for example, 
most Krylov solvers only need a "matrix-vector" multiplication service from the
input matrix). This 
information is provided in several places (Developer's Guide, source comments,
headers) in the form 
of type information.

\item 
{\bf Choose a matrix class that is compatible with your solvers/preconditioners and your
conceptual 
interface.} This can be done by inspecting the documentation, or alternatively,
by running a small 
problem size, as compatibility is checked within \hypre{} at runtime and produces
an error condition 
(errors are discussed more fully later) if the types are found to be
incompatible.

\end{enumerate}

Once the previous set of decisions have been made, it is time to code your application 
to call HYRPE:

\begin{itemize}

\item
{\bf Build any necessary auxiliary structures for your chosen conceptual
interface.} This includes, e.g., 
the grid and stencil structures for the structured grid interface.

\item
{\bf Build the matrix and vectors through your chosen conceptual interface.} Each
conceptual interface 
provides a series of calls for entering information about your problem into
\hypre{}.

\item
{\bf Build solvers and preconditioners by giving them the input matrix.}

\item
{\bf Set solver parameters.} Some parameters like convergence tolerance are the
same across solvers, 
while others are solver specific.

\item
{\bf Call the solve function for the solver.}

\item
{\bf Retrieve desired information from solver.} Depending on your application,
there may be different 
things you may want to do with the solution vector. Also, performance
information such as number of 
iterations is typically available, though it may differ from solver to solver.

\end{itemize}


{\bf Note on capitalization:} We use \code{HYPRE} and \code{hypre }
to divide \hypre{}'s function
calls into two kinds: 
those supported for users, and internal function calls. Expert users are
welcome to dig into \hypre{} source 
code and use internal function calls if they want to, but we make no promise
that those functions are fully 
supported or fully tested, nor that they will not change in future releases of
\hypre{}. 


