%==========================================================================
\chapter{Additional Information}

%==========================================================================

\section{Building the Library}

Once the user has obtained and unpacked the distribution tar file, \hypre{} can be built
by simply typing \kbd{./configure} followed by \kbd{make} in the top-level source directory.
The following sections describe some of the options for confiugring and making the
\hypre{} library.

\subsection{Getting the Library}

The \hypre{} distribution tar file is available from the Software link of the
\hypre{} web page, \htmladdnormallink{http://www.llnl.gov/CASC/hypre/}
{http://www.llnl.gov/CASC/hypre/}. 
The \hypre{} Software distribution page allows access to the tar files of the
latest and previous general and beta distributions as well as documentation. 

After unpacking the HYPRE tar file, the distribution will be in a 
subdirectory named hypre-<VERSION>, where <VERSION> is the current version number
(e.g., hypre-1.8.4, with a "b" appended if the release is a beta).
The following example shows how to unpack the tar file, move into the \hypre{}
directory and a sample directory listing.
\begin{ttfamily}
\begin{mdseries}
\linebreak
\$ \textbf{gzip -cd hypre-1.8.4b.tar.gz | tar -xf -}\linebreak
\$ \textbf{cd hypre-1.8.4b}\linebreak
\$ \textbf{ls}\linebreak
\begin{verbatim}
CHANGELOG                 INSTALL                   docs
COPYRIGHT_and_DISCLAIMER  README                    src
\end{verbatim}
\$ \textbf{cd src}\linebreak
\$ \textbf{ls}\linebreak
\begin{verbatim}
aclocal.m4     configure           HYPRE_config.h  lib            parcsr_mv   struct_mv
babel          distributed_ls      HYPRE.h         Makefile       seq_mv      tarch
babel-runtime  distributed_matrix  IJ_mv           matrix_matrix  sstruct_ls  test
blas           eigensolvers        krylov          nopoe          sstruct_mv  utilities
config         FEI_mv              lapack          parcsr_ls      struct_ls
\end{verbatim}
\end{mdseries}
\end{ttfamily}


%==========================================================================
\subsection{Configure and Make}
\label{Configure and Make}

Now that all of the files are available, \hypre{} is ready to be configured and 
made for the host platform.  The simplest method is to configure, compile and
install the libraries in \file{hypre/lib} and \file{hypre/include} directories, which is
accomplished by:
\begin{verbatim}
   ./configure
   make
\end{verbatim}

Of course there are many options to \file{configure} and \file{make} targets to 
customize such things as installation directories, compilers used, compile and
load flags, etc.  

\file{configure} searches for and reports the system type being used for building 
and executing, compilers being used, libraries being searched, option flags being set,
etc.  When all of the searching is done a file named \file{config.status} is created 
in the \file{src} directory.  If there were errors while configuring a file named 
\file{config.log} is left in the \file{src} directory when \file{configure} terminates. 
Upon successful completion of \file{configure} the file \file{Makefile.config} 
is created from its template \file{Makefile.config.in} and \hypre{} is ready to be made.

Executing \file{make}, with or without targets being specified, in the \file{src} directory 
initiates compiling of all of the source code and building of the \hypre{} library. 

When building HYPRE without the install target, the libraries and include files will be copied
into the default directories, \file{src/hypre/lib} and \file{src/hypre/include}, respectively.

When building HYPRE using the install target, the libraries and include files will be copied
into the directories that the user specified in the options to \file{configure},
e.g. --prefix=/usr/apps.  If none were specified the default directories are used,
\file{src/hypre/lib} and \file{src/hypre/include}.

%==========================================================================
\subsection{Configure Options}
\label{Configure Options}

\file{configure} has many options to allow the user to override and refine the 
defaults for any system. The best way to find out what options are available is
to display the help package which also includes the usage information.

NOTE: when executing on an IBM platform \file{configure} must be executed under 
the nopoe script (\file{./nopoe ./configure <option> ...<option>}) to force a single 
task to be run on the log-in node.

The results of \file{./configure --help} when run on a local Linux platform are:
\begin{verbatim}
'configure' configures hypre 1.9.xx to adapt to many kinds of systems.

Usage: ./configure [OPTION] ... [VAR=VALUE]...

To assign environment variables (e.g. CC, CFLAGS ...), specify them as
VAR=VALUE.  See below for descriptions of some of the useful variables.

Defaults for the options are specified in brackets.

Configuration:
   -h, --help		   display this help and exit
       --help=short	   display options specific to this package
       --help=recursive	   display the short help of all the included packages
   -V, --version	   display version information and exit
   -q, --quiet, --silent   do not print 'checking ...' messages
       --cache-file=FILE   cache test results in FILE [disabled]
   -C, --config-cache      alias for '--cache-file=config.cache'
   -n  --no-create         do not create output files
       --srcdir=DIR        find the sources in DIR [configure dir or '..']

Installation Directories:
   --prefix=PREFIX         install architecture-independent files in PREFIX
                           [/home/hill66/linear_solvers/hypre]
   --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX 
                           [PREFIX]

By default, 'make install' will install all files in
/home/hill66/linear_solvers/hypre/lib, /home/hill66/linear_solvers/hypre/bin, etc.

You can specify an installation prefix other than /home/hill/linear_solvers/hypre by using 
the --prefix option; for instance --prefix=$HOME.

For fine tuning of the installation directories:
   --bindir=DIR          user executables [EPREFIX/bin]
   --sbindir=DIR         system admin executables [EPREFIX/sbin]
   --libexecdir=DIR      program executables [EPREFIX/libexec]
   --datadir=DIR         read-only architecture independent data [PREFIX/share]
   --sysconfdir=DIR      read-only single machine data [PREFIX/etc]
   --sharedstatedir=DIR  modifiable architecture independent data [PREFIX/com]
   --localstatedir=DIR   modifiable architecture dependent data [PREFIX/var]
   --libdir=DIR          object code libraries [EPREFIX/lib]
   --includedir=DIR      C header files [PREFIX/include]
   --oldincludedir=DIR   C header files for non GCC [/usr/include]
   --infodir=DIR         info documentation [PREFIX/info]
   --mandir=DIR          man documentation [PREFIX/man]

System Types:
   --build=BUILD  configure for building on BUILD [guessed]
   --host=HOST    cross-compile to build programs to run on HOST [BUILD]

Optional Features:
   --disable-FEATURE             do not include FEATURE (same as --enable-FEATURE=no)
   --enable-FEATURE[=ARGS]       include FEATURE [ARG=yes]
     --enable-debug              compile for debugging
     --enable-shared             build shared libraries [default=NO]  (NOT Implemented)

Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
     --with-LD=ARG         Set linker to ARG. Environment variable 'LD' is overridden.
     --with-LDFLAGS=ARG    Set linker flags to ARG. 
                           Environment variable 'LDFLAGS' is overridden.
     --with-extra-incpath=PATH
                           Define extra include path, PATH is space delimited list of
                           directories.
     --with-extra-ldpath=PATH
                           Define extra LD path, PATH is space delimited list of
                           directories.
     --with-insure=FLAGS   FLAGS are options to pass to insure,
                           e.g. -log-file=struct.insure -append-logfile=yes will send
                           output to the specified file.  Defines gcc and g++ as the 
                           C and C++ compilers unless they are already set by the user.
                           There is NO guarantee that insure exists on the machine.
     --with-insure-to-file Forces insure output to a file named insure.log
                           Defines gcc and g++ as the C and C++ compilers unless they are
                           already set by the user.
                           There is NO guarantee that insure exists on the machine.
     --with-purify=FLAGS   FLAGS are options to pass to purify,
                           e.g. -log-file=struct.purify -append-logfile=yes will send
                           output to the specified file.  Defines gcc and g++ as the 
                           C and C++ compilers unless they are already set by the user.
                           There is NO guarantee that purify exists on the machine.
     --with-purify-to-file Forces purify output to a file named purify.log
                           Defines gcc and g++ as the C and C++ compilers unless they are
                           already set by the user.
                           There is NO guarantee that purify exists on the machine.
     --with-strict-checking 
                           Compiles without MPI and tries to find a compiler that warns
                           of as many non-ANSI features as possible.
     --with-MPI-include=DIR 
                           User specifies that mpi.h is in DIR.  The options
                           --with-MPI-include, --with-MPI-libs and 
                           --with-MPI-lib-dirs MUST be used together.
     --with-MPI-libs=LIBS  LIBS is a space delimited list of library names needed 
                           for MPI, e.g. <nsl socket mpi>.  The options
                           --with-MPI-include, --with-MPI-libs and 
                           --with-MPI-lib-dirs MUST be used together.
     --with-MPI-lib-dirs=DIRS
                           DIRS is a space delimited list of directories containing 
                           the libraries specified by --with-MPI-libs, e.g.
                           </usr/lib /usr/local/mpi/lib>.  The options
                           --with-MPI-include, --with-MPI-libs and 
                           --with-MPI-lib-dirs MUST be used together.
     --with-MPI-flags=FLAGS
                           FLAGS is a space delimited list of whatever flags other 
                           than -l and -L are needed to link with MPI libraries. 
                           This option does NOT deactivate the auto-search for other
                           MPI information.  It MAY be used with the other MPI options 
                           or alone in conjunction with the automatic MPI search.
     --with-blas-libs=LIBS LIBS is a space delimited list of library names needed 
                           for blas.  The options --with-blas-libs and 
                           --with-blas-lib-dirs MUST be used together.
     --with-blas-lib-dirs=DIRS
                           DIRS is a space delimited list of directories containing 
                           the libraries specified by --with-blas-libs, e.g.
                           </usr/lib /usr/local/blas/lib>.  The options --with-blas-libs
                           and --with-blas-lib-dirs MUST be used together.
     --with-lapack-libs=LIBS
                           LIBS is a space delimited list of library names needed 
                           for lapack.  The options --with-lapack-libs and 
                           --with-lapack-lib-dirs MUST be used together.
     --with-lapack-lib-dirs=DIRS
                           DIRS is a space delimited list of directories containing 
                           the libraries specified by --with-lapack-libs, e.g.
                           </usr/lib /usr/local/lapack/lib>.  The options --with-lapack-libs
                           and --with-lapack-lib-dirs MUST be used together.
     --with-fei-libs=LIBS
                           LIBS is a space delimited list of library names needed 
                           for FEI.  The options --with-fei-libs, --with-fei-lib-dirs and 
                           --with-fei-inc-dirs MUST be used together.
     --with-fei-lib-dirs=DIRS
                           DIRS is a space delimited list of directories containing 
                           the libraries specified by --with-fei-libs, e.g.
                           </usr/lib /usr/local/fei/lib>.  The options --with-fei-libs
                           --with-fei-lib-dirs and --with-fei-inc-dirs MUST be used together.
     --with-fei-inc-dirs=DIRS
                           DIRS is a space delimited list of directories containing 
                           the include files specified by --with-fei-libs, e.g.
                           </usr/include /usr/local/include>.  The options --with-fei-libs
                           --with-fei-lib-dirs and --with-fei-inc-dirs MUST be used together.
     --with-COMM_SIMPLE    Do NOT use MPI derived data types.  This option is automatically
                           selected for IBM platforms, it may be user-selected for others.
     --with-timing         use HYPRE timing routines
     --with-openmp         use OpenMP; may affect compiler choice; supported using guidec on
                           IBM and Compaq
     --with-babel          use babel
     --with-mli            use MLI
     --with-MPI            DEFAULT: compiles with MPI
     --with-blas           Find a system-provided BLAS library
     --with-lapack         Find a system-provided LAPACK library

Some influential environment variables:
   CC        C compiler command
   CFLAGS    C compiler flags
   LDFLAGS   linker flags, e.g. -L<lib dir> for libraries in non-standard directory 
             <lib dir>
   CPPFLAGS  C/C++ preprocessor flags, e.g. -I<include dir> for header files in
             non-standard directory <include dir>
   CPP       C preprocessor
   CXX       C++ compiler command
   CXXFLAGS  C++ compiler flags
   F77       Fortran 77 compiler command
   FFLAGS    Fortran 77 compiler flags
   CXXCPP    C++ preprocessor

Use these variables to override the choices made by 'configure' or to help
it find libraries and programs with non-standard names/locations.

Report bugs to <http://www-casc.llnl.gov/bugs/enter_bug.cgi?product=HYPRE>.
\end{verbatim}

%==========================================================================
\subsubsection{Configure Execution and Sample Output}
\label{Configure Execution and Sample Output}

\begin{verbatim}
Usage: ./configure [OPTION] ... [VAR=VALUE]...
\end{verbatim}

Examples of using \file{configure} with options and variable settings.  The user can mix 
and match the options and variable settings as needed to satisfy their requirements.
\begin{verbatim}
./configure --with-openmp --enable-debug

./configure  CC=mpiicc --with-babel

./configure  --with-blas-lib="essl" --with-blas-lib-dirs="/usr/lib"
\end{verbatim}


The output from \file{configure} is several pages long.  It reports the system type 
being used for building and executing, compilers being used, libraries being searched,
option flags being set, etc.  

The following is a very short sample of \file{configure} output.
\begin{verbatim}
./configure

checking build system type. . . i686-pc-linux-gnu
checking host system type. . . i686-pc-linux-gnu
checking for mpcc. . . no
checking for mpikcc. . . no
checking for mpicc. . . mpicc
checking for mpCC. . . no
checking for mpiKCC. . . no
checking for mpiCC. . . mpiCC
checking for mpxlf. . . no
checking for mpikf77. . . no
checking for mpif77. . . mpif77
checking whether the C compiler works. . . yes
checking for egrep. . . grep -E
checking for sys/types.h. . . yes
checking for float.h. . . yes
checking for dgemm_ in -lessl. . .  no
                 .
                 .
                 .
configure: creating ./config.status
config.status: creating Makefile.config
config.status: creating HYPRE_config.h
config.status: HYPRE_config.h is unchanged

\end{verbatim}

%==========================================================================
\subsection{Make Targets}
\label{Make Targets}

The make step in building \hypre{} is where the compiling, loading and creation 
of libraries occurs.  Make has several options that are called targets.  These include:
\begin{verbatim}
   help         prints the details of each target

   all          default target in all directories
                compile the entire library
                does NOT rebuild documentation

   clean        deletes all files from the current directory that are 
                   created by building the library

   distclean    deletes all files from the current directory that are created
                   by configuring or building the library

   install      compile the source code, build the library and copy executables,
                    libraries, etc to the appropriate directories for user access

   uninstall    deletes all files that the install target created

   tags         runs etags to create a tags table
                file is named TAGS and is saved in the top-level directory

   test         depends on the all target to be completed
                removes existing temporary installation directories
                creates temporary installation directories
                copies all libHYPRE* and *.h files to the temporary locations
                builds the test drivers; linking to the temporary locations to
                   simulate how application codes will link to HYPRE
\end{verbatim}


%==========================================================================
\subsubsection{Make Execution and Sample Output}
\label{Make Execution and Sample Output}

\begin{verbatim}
Usage: make [TARGET]
\end{verbatim}

Examples of using \file{make} with different targets.  Only ONE target can be specified at a time. 
\begin{verbatim}
make

make install

make test
\end{verbatim}

The execution of \file{make} creates several pages of output.  The following is a brief 
sample of the command \file{make}.
\begin{verbatim}

Output from make:
make[3]: Entering directory '/home/hill66/linear_solvers/krylov
mpicc -O2 -I.. -I./.. -I./../multivector -I./../utilities -DHAVE_CONFIG_H -c cgnr.c
mpicc -O2 -I.. -I./.. -I./../multivector -I./../utilities -DHAVE_CONFIG_H -c gmres.c
mpicc -O2 -I.. -I./.. -I./../multivector -I./../utilities -DHAVE_CONFIG_H -c pcg.c
mpicc -O2 -I.. -I./.. -I./../multivector -I./../utilities -DHAVE_CONFIG_H -c HYPRE_lobpcg.c
Building libHYPRE_krylov.a ...
ar -rcu libHYPRE_krylov.a cngr.o gmres.o pcg.o HYPRE_lobpcg.o
ranlib libHYPRE_krylov.a
cp -fp ./krylov.h /home/hill66/linear_solvers/hypre/include
cp -fp ./*lobpcg*.h /home/hill66/linear_solvers/hypre/include
cp -fp libHYPRE* /home/hill66/linear_solvers/hypre/lib
make[3]: Leaving directory '/home/hill66/linear_solvers/krylov

\end{verbatim}


%==========================================================================
\subsection{Testing the Library} 

The \kbd{test} subdirectory contains several codes that can be used to test
the newly created \hypre{} library.  To create the executable verions, move into
the \kbd{test} subdirectory, enter \kbd{make test} then execute the codes as described
by their help packages.


%==========================================================================

\subsection{Linking to the Library}

An application code linking with \hypre{} must be compiled with \kbd{-I\$PREFIX/include} 
and linked with \kbd{-L\$PREFIX/lib -l}{\it hypre library name}... 
\kbd{-l}{\it hypre library name}..., where \kbd{\$PREFIX} is the
directory where \hypre{} is installed, specified by the configure
option \kbd{--prefix=PREFIX}.  Additionally, any other libraries to which \hypre{} 
is linked must also be linked to by the users application. 

As an example of linking with \hypre{}, a user may refer to the \kbd{Makefile} in the 
\file{test} subdirectory.  It is designed to build test applications that link with and 
call \hypre{}.  All include and linking flags are defined in the \file{Makefile.config} 
file by \file{configure}.


%==========================================================================

\section{Calling HYPRE from Fortran}
\label{Calling HYPRE from Fortran}

\hypre{} provides a Fortran interface to enable such applications to call its C
routines.  Typically, the Fortran subroutine name is the same as the C name, unless 
it is longer than 31 characters.  In these situations, the name is condensed to 31
characters, usually by simple truncation.  For now, users should look at the Fortran 
test drivers in the \code{test} directory for the correct condensed names.  In the future,
this aspect of the interface conversion will be made consistent and straightforward.

The Fortran subroutine argument list is always the same as the corresponding C routine, 
except that the error return code \code{ierr} is always last.  Conversion from C parameter
types to Fortran argument type is summarized in Table \ref{table-fortran-interface-types}.

\begin{table}
\center
\begin{tabular}{|l|l|}
\hline
C parameter & Fortran argument \\
\hline\hline
\code{int i} & \code{integer i} \\
\code{double d} & \code{double precision d} \\
\code{int *array} & \code{integer array(*)} \\
\code{double *array} & \code{double precision array(*)} \\
\code{char *string} & \code{character string(*)} \\
\code{HYPRE\_Type object} & \code{integer*8 object} \\
\code{HYPRE\_Type *object} & \code{integer*8 object} \\
\hline
\end{tabular}
\caption{%
Conversion from C parameters to Fortran arguments
}
\label{table-fortran-interface-types}
\end{table}


Array arguments in \hypre{} are always of type \code{(int *)} or \code{(double *)}, 
and the corresponding Fortran types are simply \code{integer} or \code{double precision} 
arrays.  Note that the Fortran arrays may be indexed in any manner.  For example, an integer
array of length \code{N} may be declared in fortran as either of the following:
\begin{display}
\begin{verbatim}
      integer  array(N)
      integer  array(0:N-1)
\end{verbatim}
\end{display}

\hypre{} objects can usually be declared as in the table because \code{integer*8} 
usually corresponds to the length of a pointer.  However, there may be some machines
where this is not the case (although we are not aware of any at this time).  On such
machines, the Fortran type for a \hypre{} object should be an \code{integer} of
the appropriate length.

This simple example illustrates the above information: 

\hypre{} prototype:
\begin{display}
\begin{verbatim}
int HYPRE_IJMatrixSetValues(HYPRE_IJMatrix  matrix,
                            int  nrows, int  *ncols,
                            const int *rows, const int  *cols,
                            const double  *values);
\end{verbatim}
\end{display}

The corresponding Fortran code for calling this routine is as follows:
\begin{display}
\begin{verbatim}
      integer*8         matrix, 
      integer           nrows, ncols(MAX_NCOLS)
      integer           rows(MAX_ROWS), cols(MAX_COLS)
      double precision  values(MAX_COLS)
      integer           ierr

      call HYPRE_IJMatrixSetValues(matrix, nrows, ncols, rows, cols,
     &                             values, ierr)
\end{verbatim}
\end{display}

%Fortran 77 subroutine arguments always pass copies of the argument
%addresses upon execution of the subroutine call.  This is referred to
%as call-by-address or call-by-reference.  In the called subroutine,
%the memory space at the argument address can be altered, but the
%calling address cannot be altered.
%
%C function parameters, whether pointers (addresses) or not, are
%directly copied upon entry to the function. This is referred to as
%call-by-value.  Altering the copied C parameter in the called function
%has no effect on the parameter in the calling function.  A pointer
%parameter in C can achieve the same effect as call-by-reference, and
%by this mechanism the languages can interoperate in a straightforward
%manner.
%
%Portability across typical platforms is currently achieved with the
%specific Fortran-calling-C mapping:
%
%\vspace{0.2in}
%
%\begin{tabular}{lcl}
%
%\underline{calling Fortran argument type} & &
%\underline{called C function parameter type} \\
%                              &                   &   \\
%\hspace{0.1in} (addr of) \code{integer*8}        & $\longrightarrow$ &
%\hspace{0.5in} \code{long int*} \\
%\hspace{0.1in} (addr of) \code{integer}          & $\longrightarrow$ &
%\hspace{0.5in} \code{int*} \\
%\hspace{0.1in} (addr of) \code{character}        & $\longrightarrow$ &
%\hspace{0.5in} \code{char*} \\
%\hspace{0.1in} (addr of) \code{double precision} & $\longrightarrow$ &
%\hspace{0.5in} \code{double*} \\
%
%\end{tabular}
%
%\vspace{0.2in}
%
%In particular, C-type
%\code{long int*} points to a space that can hold an address, a space
%which happens to be the size of that allocated by a Fortran
%\code{integer*8} declaration.
%In other words, C can hold an address in a \code{long int} and
%assign that address to a Fortran \code{integer*8} memory space
%(using \code{long int*} call-by-value).
%
%Addresses in \code{integer*8} variables might not have originated
%in a Fortran call, and if they address inhomogeneously typed collections
%of data (e.g. C structures), Fortran might not have enough information to
%dereference them.  But Fortran can still pass around such addresses, and in
%particular hand them back and forth between various C functions.  The
%\hypre{} Fortran interface makes extensive use of this technique,
%as with the \code{addr} variable in the following general example:
%
%\vspace{0.1in}
%
%\noindent Generalized example:
%
%\vspace{0.1in}
%
%  Fortran calling:
%\begin{verbatim}
%      integer*8        addr
%      integer          intg, ierr
%      character        charact
%      double precision double_precis
%
%      call subroutine_name(addr, intg, charact, double_precis, ierr)
%\end{verbatim}
%
%The interface is designed so that the label \code{subroutine_name} is
%exactly the label of the \hypre{} C-function\footnote{For C function
%names under 32 characters in length, the Fortran name is the same as
%the C name.  For C function names over 31 characters, the Fortran name
%is condensed to less than 32 characters (see reference manual for
%Fortran name in such a case).}.  \hypre{} interlanguage C-wrappers
%currently account for interlanguage linking issues involving appended
%underscores.  The C-wrappers also accomodate Fortran subroutine name
%length limitations.  Fortran variable
%\code{ierr} allows error handling through the interface.
%
%\vspace{0.1in}
%
%\noindent Specific example:
%
%\vspace{0.1in}
%
%  Fortran calling:
%\begin{verbatim}
%      integer*8        IJmatrix, 
%      integer          num_nonzero_coefs, row_index
%      integer          col_indices(MAX_NUM_COLS), ierr
%      double precision coefs(MAX_NUM_COLS)
%             .
%             .
%             .
%
%      call HYPRE_IJMatrixInsertRow(IJmatrix, num_nonzero_coefs, row_index,
%                                   col_indices, coefs, ierr)
%\end{verbatim}
%
%\vspace{0.1in}
%
%  C called:
%\begin{verbatim}
%      int HYPRE_IJMatrixInsertRow( HYPRE_IJMatrix IJmatrix, int n,
%                                   int row, const int *cols,
%                                   const double *values)     
%
%      { int ierr = 0;
%              .
%              .
%              .
%
%        return(ierr); }
%\end{verbatim}
%
%\noindent Since the C function name has less than 32 characters, Fortran
%uses the same name in the subroutine call.

%==========================================================================

\section{Bug Reporting}

\hypre{} has an automated bug reporting mechanism that may be used for submitting 
bugs, desired features and documentation problems, as well as querying the status 
of previous reports.  Access \htmladdnormallink{http://www-casc.llnl.gov/bugs}
{http://www-casc.llnl.gov/bugs} for full bug tracking details or to submit or query
a bug report.  When using the site for the first time, click on
``Open a new Bugzilla account'' under the ``User login account management'' heading.

%==========================================================================
