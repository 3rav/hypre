%=============================================================================
%=============================================================================

\chapter{Building the HYPRE Library}

%-----------------------------------------------------------------------------

\section{Getting the Source Code}

The \hypre{} distribution tar file is available from the Software link of the
\hypre{} web page, \url{http://www.llnl.gov/CASC/hypre/}.  The \hypre{}
Software distribution page allows access to the tar files of the latest and
previous general and beta distributions as well as documentation.

%-----------------------------

\section{Configure and Make}

After unpacking the HYPRE tar file, the source code will be in the "src" 
sub-directory of a directory named hypre-VERSION, where VERSION is the current 
version number (e.g., hypre-1.8.4, with a "b" appended for a beta release).

Now that all of the files are available, move to the "src" sub-directory to build
\hypre{} for the host platform.  The simplest method is to configure, compile and
install the libraries in \file{./hypre/lib} and \file{./hypre/include} directories,
which is accomplished by:
\begin{verbatim}
   ./configure
   make
\end{verbatim}

There are many options to \file{configure} and \file{make} to customize such 
things as installation directories, compilers used, compile and load flags, etc.

Executing \file{configure} results in the creation of platform specific files 
that are used when building the library. The information may include such things
as the system type being used for building and executing, compilers being used, 
libraries being searched, option flags being set, etc.  When all of the searching
is done two files are left in the \file{src} directory; \file{config.status} 
contains information to recreate the current configuration and \file{config.log}
contains compiler messages which may help in debugging \file{configure} errors. 

Upon successful completion of \file{configure} the file \file{config/Makefile.config} 
is created from its template \file{config/Makefile.config.in} and \hypre{} is 
ready to be built.

Executing \file{make}, with or without targets being specified, in the \file{src}
directory initiates compiling of all of the source code and building of the \hypre{} 
library. 

When building HYPRE without the install target, the libraries and include files 
will be copied into the default directories, \file{src/hypre/lib} and 
\file{src/hypre/include}, respectively.

When building HYPRE using the install target, the libraries and include files 
will be copied into the directories that the user specified in the options to 
\file{configure}, e.g. --prefix=/usr/apps.  If none were specified the default 
directories are used, \file{src/hypre/lib} and \file{src/hypre/include}.

%-----------------------------

\subsection{Configure Options}

There are many options to \file{configure} to allow the user to override and 
refine the defaults for any system. The best way to find out what options are 
available is to display the help package, by executing \file{./configure --help}, which 
also includes the usage information.

NOTE: when executing on an IBM platform \file{configure} must be executed under 
the nopoe script (\file{./nopoe ./configure <option> ...<option>}) to force a single 
task to be run on the log-in node.


%==========================================================================
\subsection{Configure Execution}

\begin{verbatim}
Usage: ./configure [OPTION] ... [VAR=VALUE]...
\end{verbatim}

Examples of using \file{configure} with options and variable settings.  The user can mix 
and match the options and variable settings as needed to satisfy their requirements.
\begin{verbatim}
./configure --with-openmp --enable-debug

./configure  CC=mpiicc --with-babel

./configure  --with-blas-lib="essl" --with-blas-lib-dirs="/usr/lib"
\end{verbatim}


The output from \file{configure} is several pages long.  It reports the system type 
being used for building and executing, compilers being used, libraries being searched,
option flags being set, etc.  

%-----------------------------

\subsection{Make Targets}

The make step in building \hypre{} is where the compiling, loading and creation 
of libraries occurs.  Make has several options that are called targets.  These include:
\begin{verbatim}
   help         prints the details of each target

   all          default target in all directories
                compile the entire library
                does NOT rebuild documentation

   clean        deletes all files from the current directory that are 
                   created by building the library

   distclean    deletes all files from the current directory that are created
                   by configuring or building the library

   install      compile the source code, build the library and copy executables,
                    libraries, etc to the appropriate directories for user access

   uninstall    deletes all files that the install target created

   tags         runs etags to create a tags table
                file is named TAGS and is saved in the top-level directory

   test         depends on the all target to be completed
                removes existing temporary installation directories
                creates temporary installation directories
                copies all libHYPRE* and *.h files to the temporary locations
                builds the test drivers; linking to the temporary locations to
                   simulate how application codes will link to HYPRE
\end{verbatim}


%==========================================================================
\subsection{Make Execution}

\begin{verbatim}
Usage: make [TARGET]
\end{verbatim}

Examples of using \file{make} with different targets.  Note that only ONE target 
can be specified at a time. The output from \file{make} is several pages long.
\begin{verbatim}
make

make install

make test
\end{verbatim}


%-----------------------------

\section{Testing the Library} 

The \kbd{test} subdirectory contains several codes that can be used to test
the newly created \hypre{} library.  To create the executable versions, move into
the \kbd{test} subdirectory, enter \kbd{make test} then execute the codes as described
by their help packages.

%-----------------------------

\section{Linking to the Library}

An application code linking with \hypre{} must be compiled with \kbd{-I\$PREFIX/include} 
and linked with \kbd{-L\$PREFIX/lib -l}{\it hypre library name}... 
\kbd{-l}{\it hypre library name}..., where \kbd{\$PREFIX} is the
directory where \hypre{} is installed, specified by the configure
option \kbd{--prefix=PREFIX}.  Additionally, any other libraries to which \hypre{} 
is linked must also be linked to by the users application. 

As an example of linking with \hypre{}, a user may refer to the \kbd{Makefile} in the 
\file{test} subdirectory.  It is designed to build test applications that link with and 
call \hypre{}.  All include and linking flags are defined in the \file{Makefile.config} 
file by \file{configure}.


%-----------------------------------------------------------------------------

\section{Calling HYPRE from Fortran}

A Fortran interface is provided in \hypre{} to enable such applications to call its C
routines.  Typically, the Fortran subroutine name is the same as the C name, unless 
it is longer than 31 characters.  In these situations, the name is condensed to 31
characters, usually by simple truncation.  For now, users should look at the Fortran 
test drivers (*.f codes) in the \code{test} directory for the correct condensed 
names.  In the future, this aspect of the interface conversion will be made 
consistent and straightforward.

The Fortran subroutine argument list is always the same as the corresponding C routine, 
except that the error return code \code{ierr} is always last.  Conversion from C parameter
types to Fortran argument type is summarized in Table \ref{table-fortran-interface-types}.

\begin{table}
\center
\begin{tabular}{|l|l|}
\hline
C parameter & Fortran argument \\
\hline\hline
\code{int i} & \code{integer i} \\
\code{double d} & \code{double precision d} \\
\code{int *array} & \code{integer array(*)} \\
\code{double *array} & \code{double precision array(*)} \\
\code{char *string} & \code{character string(*)} \\
\code{HYPRE\_Type object} & \code{integer*8 object} \\
\code{HYPRE\_Type *object} & \code{integer*8 object} \\
\hline
\end{tabular}
\caption{%
Conversion from C parameters to Fortran arguments
}
\label{table-fortran-interface-types}
\end{table}


Array arguments in \hypre{} are always of type \code{(int *)} or \code{(double *)}, 
and the corresponding Fortran types are simply \code{integer} or \code{double precision} 
arrays.  Note that the Fortran arrays may be indexed in any manner.  For example, an integer
array of length \code{N} may be declared in fortran as either of the following:
\begin{display}
\begin{verbatim}
      integer  array(N)
      integer  array(0:N-1)
\end{verbatim}
\end{display}

\hypre{} objects can usually be declared as in the table because \code{integer*8} 
usually corresponds to the length of a pointer.  However, there may be some machines
where this is not the case (although we are not aware of any at this time).  On such
machines, the Fortran type for a \hypre{} object should be an \code{integer} of
the appropriate length.

This simple example illustrates the above information: 

C prototype:
\begin{display}
\begin{verbatim}
int HYPRE_IJMatrixSetValues(HYPRE_IJMatrix  matrix,
                            int  nrows, int  *ncols,
                            const int *rows, const int  *cols,
                            const double  *values);
\end{verbatim}
\end{display}

The corresponding Fortran code for calling this routine is as follows:
\begin{display}
\begin{verbatim}
      integer*8         matrix, 
      integer           nrows, ncols(MAX_NCOLS)
      integer           rows(MAX_ROWS), cols(MAX_COLS)
      double precision  values(MAX_COLS)
      integer           ierr

      call HYPRE_IJMatrixSetValues(matrix, nrows, ncols, rows, cols,
     &                             values, ierr)
\end{verbatim}
\end{display}

%Fortran 77 subroutine arguments always pass copies of the argument
%addresses upon execution of the subroutine call.  This is referred to
%as call-by-address or call-by-reference.  In the called subroutine,
%the memory space at the argument address can be altered, but the
%calling address cannot be altered.
%
%C function parameters, whether pointers (addresses) or not, are
%directly copied upon entry to the function. This is referred to as
%call-by-value.  Altering the copied C parameter in the called function
%has no effect on the parameter in the calling function.  A pointer
%parameter in C can achieve the same effect as call-by-reference, and
%by this mechanism the languages can interoperate in a straightforward
%manner.
%
%Portability across typical platforms is currently achieved with the
%specific Fortran-calling-C mapping:
%
%\vspace{0.2in}
%
%\begin{tabular}{lcl}
%
%\underline{calling Fortran argument type} & &
%\underline{called C function parameter type} \\
%                              &                   &   \\
%\hspace{0.1in} (addr of) \code{integer*8}        & $\longrightarrow$ &
%\hspace{0.5in} \code{long int*} \\
%\hspace{0.1in} (addr of) \code{integer}          & $\longrightarrow$ &
%\hspace{0.5in} \code{int*} \\
%\hspace{0.1in} (addr of) \code{character}        & $\longrightarrow$ &
%\hspace{0.5in} \code{char*} \\
%\hspace{0.1in} (addr of) \code{double precision} & $\longrightarrow$ &
%\hspace{0.5in} \code{double*} \\
%
%\end{tabular}
%
%\vspace{0.2in}
%
%In particular, C-type
%\code{long int*} points to a space that can hold an address, a space
%which happens to be the size of that allocated by a Fortran
%\code{integer*8} declaration.
%In other words, C can hold an address in a \code{long int} and
%assign that address to a Fortran \code{integer*8} memory space
%(using \code{long int*} call-by-value).
%
%Addresses in \code{integer*8} variables might not have originated
%in a Fortran call, and if they address inhomogeneously typed collections
%of data (e.g. C structures), Fortran might not have enough information to
%dereference them.  But Fortran can still pass around such addresses, and in
%particular hand them back and forth between various C functions.  The
%\hypre{} Fortran interface makes extensive use of this technique,
%as with the \code{addr} variable in the following general example:
%
%\vspace{0.1in}
%
%\noindent Generalized example:
%
%\vspace{0.1in}
%
%  Fortran calling:
%\begin{verbatim}
%      integer*8        addr
%      integer          intg, ierr
%      character        charact
%      double precision double_precis
%
%      call subroutine_name(addr, intg, charact, double_precis, ierr)
%\end{verbatim}
%
%The interface is designed so that the label \code{subroutine_name} is
%exactly the label of the \hypre{} C-function\footnote{For C function
%names under 32 characters in length, the Fortran name is the same as
%the C name.  For C function names over 31 characters, the Fortran name
%is condensed to less than 32 characters (see reference manual for
%Fortran name in such a case).}.  \hypre{} interlanguage C-wrappers
%currently account for interlanguage linking issues involving appended
%underscores.  The C-wrappers also accomodate Fortran subroutine name
%length limitations.  Fortran variable
%\code{ierr} allows error handling through the interface.
%
%\vspace{0.1in}
%
%\noindent Specific example:
%
%\vspace{0.1in}
%
%  Fortran calling:
%\begin{verbatim}
%      integer*8        IJmatrix, 
%      integer          num_nonzero_coefs, row_index
%      integer          col_indices(MAX_NUM_COLS), ierr
%      double precision coefs(MAX_NUM_COLS)
%             .
%             .
%             .
%
%      call HYPRE_IJMatrixInsertRow(IJmatrix, num_nonzero_coefs, row_index,
%                                   col_indices, coefs, ierr)
%\end{verbatim}
%
%\vspace{0.1in}
%
%  C called:
%\begin{verbatim}
%      int HYPRE_IJMatrixInsertRow( HYPRE_IJMatrix IJmatrix, int n,
%                                   int row, const int *cols,
%                                   const double *values)     
%
%      { int ierr = 0;
%              .
%              .
%              .
%
%        return(ierr); }
%\end{verbatim}
%
%\noindent Since the C function name has less than 32 characters, Fortran
%uses the same name in the subroutine call.

%-----------------------------------------------------------------------------

\section{Bug Reporting}

An automated bug reporting mechanism has been set up for \hypre{} to be used for
submitting bugs, desired features and documentation problems, as well as
querying the status of previous reports.  Access
\url{http://www-casc.llnl.gov/bugs} for full bug tracking details or to submit
or query a bug report.  When using the site for the first time, click on ``Open
a new Bugzilla account'' under the ``User login account management'' heading.
