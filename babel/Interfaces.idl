/*
 * This is the HYPRE SIDL interface description file.  It is an example of a
 * SIDL description file.  This work was presented at the 2001 SIAM Parallel
 * Processing conference.  The authors are Andy Cleary, Jeff Painter, and Cal
 * Ribbens (from HYPRE) and Scott Kohn and Gary Kumfert (from Components).
 *
 * Questions about the syntax of this file should be directed to either Scott
 * or Gary at components@llnl.gov.
 *
 * All SIDL files begin with a series of version statements.  You must provide
 * a version for any new packages defined in the symbol file.  You may also
 * provide version statements for any packages you reference in your file.
 * If you do not explicitly provide a version statement, then the most recent
 * version of the external package will be used.  For example, this file does
 * does not explicitly state which version of the SIDL classes it expects, so
 * it will always receive the most recent version of the SIDL base classes.
 *
 * Additional edits and mods begun by Andy Cleary, July 2001 
 */
version Hypre 0.1.5;


/**
 * The <code>Hypre</code> package defines interfaces for an experimental
 * version of the HYPRE software package that used SIDL and Babel to generate
 * foreign language bindings. 
 */
package Hypre {

//
// -------------------------- Interfaces ---------------------------
//


   interface Vector {
      /**
       * y <- 0 (where y=self)
       */
      int Clear ();

      /**
       * y <- x 
       */
      int Copy (in Vector x);

      /**
       * create an x compatible with y
       */
      int Clone (out Vector x);

      /**
       * y <- a*y 
       */
      int Scale (in double a);

      /**
       * d <- (y,x)
       */
      int Dot (in Vector x, out double d);

      /**
       * y <- a*x + y
       */
      int Axpy (in double a, in Vector x);
   }


   /**
    * <p>The purpose of a ProblemDefinition is to:</p>
    * <ul>
    * <li>present the user with a particular view of how to define
    *     a problem</li>
    * <li>construct and return a "problem object"</li>
    * </ul>
    *
    * <p>A "problem object" is an intentionally vague term that corresponds
    * to any useful object used to define a problem.  Prime examples are:</p>
    * <ul>
    * <li>a LinearOperator object, i.e., something with a matvec</li>
    * <li>a MatrixAccess object, i.e., something with a getrow</li>
    * <li>a Vector, i.e., something with a dot, axpy, ...</li>
    * </ul>
    *
    * <p>Note that the terms "Initialize" and "Assemble" are reserved here
    * for defining problem objects through a particular user interface.</p>
   */

   interface ProblemDefinition 
   {
      int SetCommunicator (in opaque mpi_comm);

      /**
       * Prepare an object for setting coefficient values, whether for
       * the first time or subsequently.
       *
      **/
      int Initialize ();           // "get ready to accept new values"

      /**
       * Finalize the construction of an object before using, either for
       * the first time or on subsequent uses. "Initialize" and "Assemble"
       * always appear in a matched set, with Initialize preceding Assemble. Values
       * can only be set in between a call to Initialize and Assemble.
       *
      **/
      int Assemble ();             // "done accepting new values"

      /**
       * The problem definition interface is a "builder" that creates an object
       * that contains the problem definition information, e.g. a matrix. To
       * perform subsequent operations with that object, it must be returned from
       * the problem definition object. "GetObject" performs this function.
       * <note>At compile time, the type of the returned object is unknown.
       * Thus, the returned type is a SIDL.BaseInterface. QueryInterface or Cast must
       * be used on the returned object to convert it into a known type.</note>
       *
      **/
      int GetObject ( out SIDL.BaseInterface A );
   }

   interface StructuredGridBuildMatrix extends ProblemDefinition 
   {
      int SetGrid (in StructGrid grid );
      int SetStencil (in StructStencil stencil );
      int SetValues (in array<int> index, 
                     in int num_stencil_indices,
                     in array<int> stencil_indices,
                     in array<double> values);
      int SetBoxValues (in array<int> ilower,
                        in array<int> iupper,
                        in int num_stencil_indices,
                        in array<int> stencil_indices,
                        in array<double> values);
      int SetNumGhost (in array<int> num_ghost);
      int SetSymmetric (in int symmetric);
   }

   interface StructuredGridBuildVector extends ProblemDefinition 
   {
      int SetGrid (in StructGrid grid );
      int SetStencil (in StructStencil stencil );   // really needed?
      int SetValue (in array<int> grid_index, in double value);
      int SetBoxValues (in array<int> ilower,
                        in array<int> iupper,
                        in array<double> values);
   }

   /**
    *
    * This interface represents a linear-algebraic conceptual view of a
    * linear system.  The 'I' and 'J' in the name are meant to be
    * mnemonic for the traditional matrix notation A(I,J).
    *
    **/

  interface IJBuildMatrix extends ProblemDefinition 
  {
/**
 * Create a matrix object.  Each process owns some unique consecutive
 * range of rows, indicated by the global row indices {\tt ilower} and
 * {\tt iupper}.  The row data is required to be such that the value
 * of {\tt ilower} on any process $p$ be exactly one more than the
 * value of {\tt iupper} on process $p-1$.  Note that the first row of
 * the global matrix may start with any integer value.  In particular,
 * one may use zero- or one-based indexing.
 *
 * For square matrices, {\tt jlower} and {\tt jupper} typically should
 * match {\tt ilower} and {\tt iupper}, respectively.  For rectangular
 * matrices, {\tt jlower} and {\tt jupper} should define a
 * partitioning of the columns.  This partitioning must be used for
 * any vector $v$ that will be used in matrix-vector products with the
 * rectangular matrix.  The matrix data structure may use {\tt jlower}
 * and {\tt jupper} to store the diagonal blocks (rectangular in
 * general) of the matrix separately from the rest of the matrix.
 *
 * Collective.
 *
 **/
      int Create( in int ilower, in int iupper,
                  in int jlower, in int jupper );

/**
 * Sets values for {\tt nrows} of the matrix.  The arrays {\tt ncols}
 * and {\tt rows} are of dimension {\tt nrows} and contain the number
 * of columns in each row and the row indices, respectively.  The
 * array {\tt cols} contains the column indices for each of the {\tt
 * rows}, and is ordered by rows.  The data in the {\tt values} array
 * corresponds directly to the column entries in {\tt cols}.  Erases
 * any previous values at the specified locations and replaces them
 * with new ones, or, if there was no value there before, inserts a
 * new one.
 *
 * Not collective.
 *
 **/
      int SetValues( in int nrows, in array<int> ncols, in array<int> rows,
                     in array<int> cols, in array<double> values );

/**
 * Adds to values for {\tt nrows} of the matrix.  Usage details are
 * analogous to \Ref{HYPRE_IJMatrixSetValues}.  Adds to any previous
 * values at the specified locations, or, if there was no value there
 * before, inserts a new one.
 *
 * Not collective.
 *
 **/
      int AddToValues( in int nrows, in array<int> ncols, in array<int> rows,
                     in array<int> cols, in array<double> values );
   /**
    * (Optional) Set the max number of nonzeros to expect in each row.
    * The array {\tt sizes} contains estimated sizes for each row on this
    * process.  This call can significantly improve the efficiency of
    * matrix construction, and should always be utilized if possible.
    *
    * Not collective.
    *
    * DEVELOPER NOTES: None.
    **/
      int SetRowSizes( in array<int> sizes );

   /**
    * (Optional) Set the max number of nonzeros to expect in each row of
    * the diagonal and off-diagonal blocks.  The diagonal block is the
    * submatrix whose column numbers correspond to rows owned by this
    * process, and the off-diagonal block is everything else.  The arrays
    * {\tt diag\_sizes} and {\tt offdiag\_sizes} contain estimated sizes
    * for each row of the diagonal and off-diagonal blocks, respectively.
    * This routine can significantly improve the efficiency of matrix
    * construction, and should always be utilized if possible.
    *
    * Not collective.
    *
    **/
     int SetDiagOffdSizes( in array<int> diag_sizes, in array<int> offdiag_sizes );

    /**
     * Read the matrix from file.  This is mainly for debugging purposes.
     **/
     int Read( in string filename,
		       in opaque comm );

    /**
     * Print the matrix to file.  This is mainly for debugging purposes.
     **/
     int Print( in string filename);

  }

  interface IJBuildVector extends ProblemDefinition 
  {
     int SetGlobalSize (in int n);
     int SetPartitioning (in array<int> partitioning);
     int SetLocalComponents (in int num_values,
                             in array<int> glob_vec_indices,
			     in array<int> value_indices,
                             in array<double> values);
     int AddtoLocalComponents (in int num_values,
                               in array<int> glob_vec_indices,
			       in array<int> value_indices,
                               in array<double> values);
     int SetLocalComponentsInBlock (in int glob_vec_index_start,
                                    in int glob_vec_index_stop,
                                    in array<int> value_indices,
                                    in array<double> values);
     int AddToLocalComponentsInBlock (in int glob_vec_index_start,
                                      in int glob_vec_index_stop,
                                      in array<int> value_indices,
                                      in array<double> values);
     /**
      * Create a vector object.  Each process owns some unique consecutive
      * range of vector unknowns, indicated by the global indices {\tt
      * jlower} and {\tt jupper}.  The data is required to be such that the
      * value of {\tt jlower} on any process $p$ be exactly one more than
      * the value of {\tt jupper} on process $p-1$.  Note that the first
      * index of the global vector may start with any integer value.  In
      * particular, one may use zero- or one-based indexing.
      *
      * Collective.
      *
      **/
     int Create( in opaque comm,
                  in int jlower,
                  in int jupper );
     /**
      * Sets values in vector.  The arrays {\tt values} and {\tt indices}
      * are of dimension {\tt nvalues} and contain the vector values to be
      * set and the corresponding global vector indices, respectively.
      * Erases any previous values at the specified locations and replaces
      * them with new ones.
      *
      * Not collective.
      *
      **/
     int SetValues( in int nvalues,
                    in array<int> indices,
                    in array<double> values);
     /**
      * Adds to values in vector.  Usage details are analogous to
      * \Ref{SetValues}.
      *
      * Not collective.
      *
      **/
     int AddToValues( in int nvalues,
                              in array<int> indices,
                              in array< double> values);
     /**
      * Read the vector from file.  This is mainly for debugging purposes.
      *
      **/
     int Read( in string filename,
	       in opaque comm );

     /**
      * Print the vector to file.  This is mainly for debugging purposes.
      **/
     int Print( in string filename);
  }

  /**
   * An Operator is anything that maps one Vector to another.
   * The terms "Setup" and "Apply" are reserved for Operators.
   * The implementation is allowed to assume that supplied parameter
   * arrays will not be destroyed.
   */
  interface Operator 
  {
     int SetCommunicator (in opaque comm);
     int SetDoubleParameter (in string name, in double value);
     int SetIntParameter (in string name, in int value);
     int SetStringParameter (in string name, in string value);
     int SetIntArrayParameter (in string name, in array<int> value);
     int SetDoubleArrayParameter (in string name, in array<double> value);
     int Setup ();
     int Apply (in Vector x, out Vector y);
  }

  interface Solver extends Operator
  {
     int SetOperator (in Operator A);
     int GetResidual (out Vector r);
     /* ... error if logging level is not high enough (0,1 are too low) */
     int SetLogging ( in int level );
     /* ... logging levels; defaults to 0.
     /* 0=no logging, 1=minimal cheap logging, >=2=do some work */
     /* Only level 0 must be implemented.  Details of other levels are
        implementation-specific. */
     /* ... SetLogging must be called before Setup and Apply. */
     int SetPrintLevel ( in int level );
     /* ...print debugging or status information; Default to 0 for nothing. */
     /* Only level 0 must be implemented.  Details of other levels are
        implementation-specific. */
     /* ... SetPrintLevel may be called any time. */
  }

  interface PreconditionedSolver extends Solver 
  {
     int SetPreconditioner (in Solver s);
     int GetPreconditionedResidual (out Vector r);
  }

  /**
   * The GetRow method will allocate space for its two output arrays on
   * the first call.  The space will be reused on subsequent calls.
   * Thus the user must not delete them, yet must not depend on the
   * data from GetRow to persist beyond the next GetRow call.
   */
  interface CoefficientAccess 
  {
     int GetRow (in int row, 
                 out int size, 
                 out array<int> col_ind,         // inout?
                 out array<double> values);
  }


//
// -------------------------- Classes ---------------------------
//

   /**
    * Define a structured stencil for a structured problem description.
    * More than one implementation is not envisioned, thus the decision has
    * been made to make this a class rather than an interface.
    */
   class StructStencil 
   {
      int SetDimension (in int dim);
      int SetSize (in int size);
      int SetElement (in int index, in array<int> offset);
   }

   /**
    * Define a structured grid class.
    */
   class StructGrid 
   {
      int SetCommunicator (in opaque MPI_comm);
      int SetDimension (in int dim);
      int SetExtents (in array<int> ilower, in array<int> iupper);
      int SetPeriodic(in array<int> periodic);
      int Assemble();
   }

  /**
   * The following are all classes that implement some subset of the above interfaces.
   */

  /**
   * A single class that implements both a build interface and an operator
   * interface. It returns itself for <code>GetConstructedObject</code>.
   */
  class StructMatrix implements-all StructuredGridBuildMatrix, Operator { }

  class StructVector implements-all StructuredGridBuildVector, Vector { }

  /**
   * A single class that implements both a build interface and an operator
   * interface. It returns itself for <code>GetConstructedObject</code>.
   */
  class ParCSRMatrix implements-all IJBuildMatrix, Operator, CoefficientAccess { }

  class ParCSRVector implements-all IJBuildVector, Vector, CoefficientAccess { }


  /**
   * This class implements the StructuredGrid user interface, but builds
   * an unstructured matrix behind the curtain.  It does this by using
   * an IJBuildMatrix (e.g., ParCSRMatrix, PETScMatrix, ...)
   * specified by the user with an extra method ...
   */
  class StructToIJMatrix implements-all StructuredGridBuildMatrix 
  {
     int SetIJMatrix (in IJBuildMatrix I);
  }

  class StructToIJVector implements-all StructuredGridBuildVector 
  {
     int SetIJVector (in IJBuildVector I);
  }

  class StructSMG implements-all Solver { }

  class ParAMG implements-all Solver { }

  class Pilut implements-all Solver { }

  class PCG implements-all PreconditionedSolver { }

  class GMRES implements-all PreconditionedSolver { }
}
