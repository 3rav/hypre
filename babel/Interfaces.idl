package Hypre {

   // Version designed to allow a generic PCG solver to be defined.
   //
   // Definition of Hypre interface.  JfP dec99 - feb00
   // Sources: partial design chart from Andy Cleary,
   // an earlier IDL file given me by Brent Smolinski
   // The case of the package name is chosen to prevent name conflicts.

   // These forward declarations are needed for the interface definitions
   // but are not otherwise needed for class declarations.
   // None of these classes cannot be taken out of the interface definitions
   // as long as we don't change Hypre - they all contain data which some
   // Babel/Hypre function passes on to a HYPRE function.
   class MPI_Com;
   class Box;
   class StructStencil;
   class StructuredGrid;
   
// ---------------- Interfaces ----------------

  interface Vector {
     int Clear ();                          // y <- 0 (where y=self)
     int Copy (in Vector x);                // y <- x 
     int Clone (out Vector x);              // create an x compatible with y
     int Scale (in double a);               // y <- a*y 
     int Dot (in Vector x, out double d);   // d <- (y,x)
     int Axpy (in double a, in Vector x);   // y <- a*x + y
  };

   interface Operator {
      int Apply( in Vector x, out Vector b );
   };
   // ... Things which inherit from Operator include Matrix, Solver.

   interface LinearOperator extends Operator {
      int Apply( in Vector x, out Vector b );
   };

   interface StructuredGridVectorBuilder {
      int SetValues( in Box box, in array<double,1> values );
      // ... this is basically how the HYPRE functions work, except that
      // ilower, iupper, and dim are combined into a Box object.  Probably
      // it would be better to encode the "values" data structure in a more
      // natural form.
      int New( in StructuredGrid grid );
      int Setup();
      Vector GetConstructedObject();
   };

   interface StructuredGridMatrixBuilder {
      int SetStencil( in StructStencil stencil );
      int SetValues( in Box box, in array<int,1> stencil_indices,
                     in array<double,1> values );
      // ... this is basically how the HYPRE functions work, except that
      // ilower, iupper, and dim are combined into a Box object.  Probably
      // it would be better to encode the "values" data structure in a more
      // natural form.
      int New( in StructuredGrid grid, in StructStencil stencil,
                in int symmetric, in array<int,1> num_ghost );
      int Setup();
      LinearOperator GetConstructedObject();
   };

   interface StructuredGridBuilder 
   {
      int SetGridExtents( in Box box );
      int SetDoubleParameter( in string name, in double value );
      int SetIntParameter( in string name, in int value );
      int SetIntArrayParameter( in string name, in array<int,1> value );
      StructuredGrid GetConstructedObject();
      int New( in MPI_Com com, in int dimension );
      int Setup();
   };
   
   interface Stencil {
      int SetElement( in int element_index, inout array<int,1> element_offset );
   };

   interface Solver extends LinearOperator {
      int Apply( in Vector b, out Vector x );
      LinearOperator GetSystemOperator();
      Vector GetResidual();
      int GetConvergenceInfo( in string name, out double value );
   };

   interface PreconditionedSolver extends Solver {
      int Apply( in Vector b, out Vector x );
      LinearOperator GetSystemOperator();
      Vector GetResidual();
      int GetConvergenceInfo( in string name, out double value );

      Solver GetPreconditioner();
   };

   interface SolverBuilder {
      double GetDoubleParameter( in string name );
      int GetIntParameter( in string name );
      int SetDoubleParameter( in string name, in double value );
      int SetIntParameter( in string name, in int value );
      int New( in MPI_Com comm );
      int Setup( in LinearOperator A, in Vector b, in Vector x );
      Solver GetConstructedObject();    
   };

   interface PreconditionedSolverBuilder extends SolverBuilder {
      double GetDoubleParameter( in string name );
      int GetIntParameter( in string name );
      int SetDoubleParameter( in string name, in double value );
      int SetIntParameter( in string name, in int value );
      int New( in MPI_Com comm );
      int Setup( in LinearOperator A, in Vector b, in Vector x );
      Solver GetConstructedObject();    

      int SetPreconditioner( in Solver precond );
   };


// ---------------- Classes ----------------

// Note re "New" and "Constructor" functions:
// There are two ways to design a class structure for the above interfaces.
// In one, for every class Foo there is a class FooBuilder.  A builder
// object makes the object you want.
// In the other design, you construct objects the "normal" way, which
// begins by calling a constructor.
//
// If you use a separate builder, the way things work is:
//  builder's Babel constructor() makes a builder
//  builder's New(...) makes an object and does basic initialization
//  builder's Set functions put data into the new object
//  builder's Setup(...) finishes building the object
//  builder's GetConstructedObject() returns that object
//
// If you use an object which implements its own builder interface, the
// way things work is simply:
//  object's Constructor(...) makes the object and does basic initialization
//  object's Set functions put data into the new object
//  object's Setup(...) finishes building the object
//
// Internally, the Constructor() combines the Babel constructor() and New(...).
// But there is no reason for a user to call them separately or even know that
// they exist.  Nevertheless, the New() function must be implemented even when
// an object is its own builder.  This is because it is needed by any separate
// builder, hence it must be declared in the builder interface.

   class MPI_Com 
   {
      // This class contains MPI information.  Potentially this can be
      // the object which answers questions like "how many processors
      // are there?". So the MPI communicator has to be passed into it
      // upon construction.
      // The problem is that I have to build into this the "secret"
      // knowledge that an MPI communicator handle is really an integer.
      int New( in int comm );
      static MPI_Com Constructor( in int comm );
   };
   
   // ---------------- Grid, matrix, vector classes

   // The "print" functions in this file print brief information
   // to stdout for debugging use.  The Matrix and Vector ones also
   // call the Hypre "Print" functions, which print their entire
   // contents to a file.

   class Box {
      int New( in array<int,1> lower, in array<int,1> upper,
                in int dimension );
      static Box Constructor( in array<int,1> lower, in array<int,1> upper,
                              in int dimension );
      int Setup();
      void print();
   };

   class StructStencil implements Stencil 
   {
      void print();
      int SetElement( in int element_index, inout array<int,1> element_offset );
      int New( in int dimension, in int size );
      static StructStencil Constructor( in int dimension, in int size );
      int Setup();
   };
   
   class StructVectorBldr implements StructuredGridVectorBuilder {
      void print();
      int SetValues( in Box box, in array<double,1> values );
      Vector GetConstructedObject();
      int New( in StructuredGrid grid );
      static StructVectorBldr Constructor( in StructuredGrid grid );
      int Setup();
   };

   class StructVector implements Vector {
     int Clear ();                    
     int Copy (in Vector x);         
     int Clone (out Vector x);       
     int Scale (in double a);        
     int Dot (in Vector x, out double d);
     int Axpy (in double a, in Vector x);
   };

   class StructMatrixBldr implements StructuredGridMatrixBuilder {
      void print();
      int SetStencil( in StructStencil stencil );
      int SetValues( in Box box, in array<int,1> stencil_indices,
                     in array<double,1> values );
      int Apply( in StructVector b, out StructVector x );
      LinearOperator GetConstructedObject();
      int New( in StructuredGrid grid, in StructStencil stencil,
                in int symmetric, in array<int,1> num_ghost  );
      static StructMatrixBldr Constructor
      ( in StructuredGrid grid, in StructStencil stencil, in int symmetric,
        in array<int,1> num_ghost );
      int Setup();
   };

   class StructMatrix implements LinearOperator {
      int Apply( in Vector x, out Vector b );
   };

   class StructuredGrid implements StructuredGridBuilder
   {
      void print();
      int SetGridExtents( in Box box );
      int SetDoubleParameter( in string name, in double value );
      int SetIntParameter( in string name, in int value );
      int SetIntArrayParameter( in string name, in array<int,1> value );
      StructuredGrid GetConstructedObject();
      int New( in MPI_Com com, in int dimension );
      static StructuredGrid Constructor( in MPI_Com com, in int dimension );
      int Setup();
   };
   
         
   // ---------------- Solver and related classes


   // Some "standard" functions can be expected to work differently on different
   // solvers, hence have keyword strings in their argument lists.
   // The generic parameter type is a double because that's easily converted
   // to int but not vice versa.

   class StructJacobi implements Solver, SolverBuilder {
      int Apply( in Vector b, out Vector x );
      LinearOperator GetSystemOperator();
      Vector GetResidual();
      int GetConvergenceInfo( in string name, out double value );

      double GetDoubleParameter( in string name );
      int GetIntParameter( in string name );
      int SetDoubleParameter( in string name, in double value );
      int SetIntParameter( in string name, in int value );
      int New( in MPI_Com comm );
      int Setup( in LinearOperator A, in Vector b, in Vector x );
      static StructJacobi Constructor( in MPI_Com comm );
      Solver GetConstructedObject();
   };

   class StructSMG implements Solver, SolverBuilder {
      int Apply( in Vector b, out Vector x );
      LinearOperator GetSystemOperator();
      Vector GetResidual();
      int GetConvergenceInfo( in string name, out double value );

      double GetDoubleParameter( in string name );
      int GetIntParameter( in string name );
      int SetDoubleParameter( in string name, in double value );
      int SetIntParameter( in string name, in int value );
      int New( in MPI_Com comm );
      int Setup( in LinearOperator A, in Vector b, in Vector x );
      static StructSMG Constructor( in MPI_Com comm );
      Solver GetConstructedObject();
   };

   class PCG implements PreconditionedSolver, PreconditionedSolverBuilder {
      int Apply( in Vector b, out Vector x );
      LinearOperator GetSystemOperator();
      Vector GetResidual();
      int GetConvergenceInfo( in string name, out double value );

      Solver GetPreconditioner();

      double GetDoubleParameter( in string name );
      int GetIntParameter( in string name );
      int SetDoubleParameter( in string name, in double value );
      int SetIntParameter( in string name, in int value );
      int New( in MPI_Com comm );
      static PCG Constructor( in MPI_Com comm );
      int Setup( in LinearOperator A, in Vector b, in Vector x );
      Solver GetConstructedObject();    

      int SetPreconditioner( in Solver precond );

   };



}
;
