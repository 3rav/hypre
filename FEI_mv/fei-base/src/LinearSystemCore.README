
When creating a specific FEI implementation, i.e., a version that
supports a specific underlying linear solver library, the main
task that must be performed is the implementation of a class that
derives from the abstract interface class, LinearSystemCore.

This is the class that holds and manipulates all solver-library-specific
stuff, such as matrices/vectors, solvers/preconditioners, etc. This
class is owned and used by the class that implements the FEI spec.
i.e., when element contributions, etc., are received from the
application, the data is ultimately passed to this class for 
assembly into the sparse matrix and associated vectors. This class
will also be asked to launch any underlying solver, and finally to
return the solution.

This class can also be asked to pass out a copy of its internal matrix
and/or vector(s), or simply a pointer to them, in a crude 'Data' container
(see the brief description of 'Data' below), and also can be asked to 
accumulate (sum) matrices or vectors into the internal matrix or vector,
respectively.

I've attempted to include enough comments for each member function
to adequately describe the required behavior. If you have remaining
questions, contact me. Alan Williams (william@sandia.gov)

* Note: these are all void functions -- you don't have the opportunity
  to return error codes. That's because at this stage, I can't imagine
  a way for the FEI implementation to correct and proceed if an error
  occurs in this class. So implementers of this class should take the
  approach of printing a DESCRIPTIVE message and aborting if an error
  is encountered.

* Note: the 'Data' class that appears in some argument lists is a
  simple container for passing void pointers with user-enforced
  type safety. This will ultimately be replaced by ESI objects, once
  the ESI effort progresses farther.

================================================================================
================================================================================

Descriptions for each member function:

================================================================================
Constructor, LinearSystemCore(MPI_Comm comm)

   The implementation can do whatever general initialization it wants
   to do here, as well as storing the MPI_Comm if it will be needed
   by the underlying solver library.

================================================================================
Destructor, ~LinearSystemCore()

   Obviously the last function called, this is where allocated memory
   should be deleted, etc.

================================================================================
void parameters(int numParams, char** params)

   For setting generic argc/argv style parameters.
   This function may be called at any time during the life of this
   class, and may be called multiple times.

   Function(s) that must already have been called:
      None

   This function will generally be the first function called after
   construction. Incoming parameters will almost always
   include (but not be limited to):
     "outputLevel n" where n=0 will request no screen output (except
                     fatal error messages), n>0 will imply some level
                     of screen output, left up to the judgement of
                     the implementer.

     "debugOutput path" where path will be the location in which you
                        should dump any debug output file(s).

================================================================================
void createMatricesAndVectors(int numGlobalEqns, 
                           int firstLocalEqn,
                           int numLocalEqns)

   Provide info for initial creation of matrix/vector data.
   The intent here is that one linear system will be declared:
   one 'A' matrix, one 'x' vector, and one 'b' (rhs) vector.
   At this point the matrix clearly can't be fully allocated, but
   initial instantiation can probably take place. The input arguments
   imply a contiguous row-wise matrix data distribution across processors,
   but that isn't required.

   Function that must already have been called:
      None

   Parameters:
      numGlobalEqns: global size 'n' of matrix A
      firstLocalEqn: first (1-based) equation owned by this processor.
      numLocalEqns:  number of equations owned by this processor.

   This function will probably be one of the first member functions
   called, and probably won't be called more than once.

   //void allocateMatrix:
   //provide enough info to allocate the matrix -- i.e., define
   //the structure. After this function has been called, the matrix
   //should be ready to receive data. The input argument colIndices
   //is a ragged 2D array: number-of-rows numLocalEqns, and the
   //number of indices in colIndices[i] is rowLengths[i].

================================================================================
void allocateMatrix(int** colIndices, int* rowLengths)

   Identify the structure of the matrix. If the implementation's matrix
   needs to be pre-allocated before data can be loaded in, this is the
   time to do it.

   Function that must already have been called:
      createMatricesAndVectors

   Parameters:
      colIndices: ragged 2D array. number-of-rows: numLocalEqns
                                   length of row 'i': rowLengths[i]
      rowLengths: list of number-of-nonzeros for each local row of the
                  matrix.

================================================================================
void resetMatrixAndVector(double s)
   Don't destroy the structure of the matrix, but set the value 's'
   throughout the matrix and vectors.
   This function will usually not be called until after a complete
   assemble/solve phase has been performed. The reset is intended to
   'empty' a matrix system when running multiple time-steps where the
   matrix structure is re-used from previous time-steps, but new
   coefficients are loaded.

   Function that must already have been called:
      allocateMatrix (but strictly speaking, a good implementation would
                      simply ignore this function if called too early.)

   Parameters:
      s: the scalar value to set throughout the matrix/vector system. This
         will almost always be zero. In fact, nobody can imagine a real
         situation where it would not be zero.
        
================================================================================
void sumIntoSystemMatrix(int row, int numValues,
                          const double* values,
                          const int* scatterIndices)

   This is the primary matrix assembly function. The coefficients 'values'
   are to be accumumlated into (added to any values already in place) the
   matrix.

   Function that must already have been called:
      allocateMatrix

   Parameters:
      row:     The global (1-based) row into which the data should go.
      numValues: How many coefficients are being provided. (i.e., not
                 necessarily the whole row)
      values: The actual coefficients.
      scatterIndices: the global (1-based) column indices for the coefficients.

================================================================================
void sumIntoRHSVector(int numValues,
                      const double* values,
                      const int* indices)

   This is the rhs vector equivalent to sumIntoSystemMatrix above.

   Function that must already have been called:
      createMatricesAndVectors

   Parameters:
      numValues: How many values are being provided.
      values: The coefficients.
      indices: Their global equation numbers (1-based).

================================================================================
void matrixLoadComplete()
   
   Do any internal synchronization/communication or whatever else is
   necessary to prepare the matrix to be used in matrix-vector products.

   Function that must already have been called:
      all calls to sumIntoSystemMatrix

================================================================================
void enforceEssentialBC(int* globalEqn,
                        double* alpha,
                        double* gamma, int len)

   Function for enforcing essential (dirichlet) boundary conditions.

   Function that must already have been called:
      matrixLoadComplete()

   Parameters:
      globalEqn: list of global (1-based) equation numbers on which
                 boundary conditions are being imposed.
      alpha: see the FEI annotated reference manual for a description of the
      gamma: alpha and beta coefficients.
      len: the length of the above lists.

================================================================================
void enforceOtherBC(int* globalEqn, double* alpha,
                    double* beta, double* gamma,
                    int len)

   Function for enforcing natural (Neumann) and mixed boundary conditions.

   Function that must already have been called.
      matrixLoadComplete()

   Parameters:
      same as those for enforceEssentialBC, but with the addition of the
      beta coefficients. see the FEI annotated reference manual for descriptions
      of these coefficients.

   //functions for getting/setting matrix or vector pointers.

   //getMatrixPtr:
   //obtain a pointer to the 'A' matrix. This should be considered a
   //constant pointer -- i.e., this class remains responsible for the
   //matrix (e.g., de-allocation upon destruction). 

   virtual void getMatrixPtr(Data& data) = 0;

   //copyInMatrix:
   //replaces the internal matrix with a copy of the input argument, scaled
   //by the coefficient 'scalar'.

   virtual void copyInMatrix(double scalar, const Data& data) = 0;

   //copyOutMatrix:
   //passes out a copy of the internal matrix, scaled by the coefficient
   //'scalar'.

   virtual void copyOutMatrix(double scalar, Data& data) = 0;

   //sumInMatrix:
   //accumulate (sum) a copy of the input argument into the internal
   //matrix, scaling the input by the coefficient 'scalar'.

   virtual void sumInMatrix(double scalar, const Data& data) = 0;

   //getRHSVectorPtr:
   //the same semantics apply here as for the getMatrixPtr functions above.

   virtual void getRHSVectorPtr(Data& data) = 0;

   //copyInRHSVector/copyOutRHSVector/sumInRHSVector:
   //the same semantics apply here as for the matrix functions above.

   virtual void copyInRHSVector(double scalar, const Data& data) = 0;
   virtual void copyOutRHSVector(double scalar, Data& data) = 0;
   virtual void sumInRHSVector(double scalar, const Data& data) = 0;

   //destroyMatrixData/destroyVectorData:
   //Utility function for destroying the matrix in a Data container. The
   //caller (owner of 'data') can't destroy the matrix because they don't
   //know what type it is and can't get to its destructor.

   virtual void destroyMatrixData(Data& data) = 0;
   virtual void destroyVectorData(Data& data) = 0;

   //functions for managing multiple rhs vectors
   virtual void setNumRHSVectors(int numRHSs, const int* rhsIDs) = 0;

   //void setRHSID:
   //set the 'current' rhs context, assuming there are multiple
   //rhs vectors.
   virtual void setRHSID(int rhsID) = 0;

   //void putInitialGuess:
   //function for setting (a subset of) the initial-guess
   //solution values (i.e., in the 'x' vector).

   virtual void putInitialGuess(const int* eqnNumbers, const double* values,
                                int len) = 0;

   //function for getting all the answers ('x' vector).
   //the returned eqnNumbers should be contiguous, and in the range 
   //'firstLocalEqn' to 'firstLocalEqn' + 'numLocalEqns' - 1, but
   //will not be assumed to be sorted.
   virtual void getSolution(int* eqnNumbers, double* answers, int len) = 0;

   //function for getting the (single) solution entry at
   //equation number 'eqnNumber'.
   virtual void getSolnEntry(int eqnNumber, double& answer) = 0;

   //function for launching the linear solver
   //on exit, solveStatus should indicate success/failure of the
   //solver, and iterations should indicate how many iterations were
   //performed.
   virtual void launchSolver(int& solveStatus, int& iterations) = 0;
};

#endif

